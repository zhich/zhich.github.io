---
title: 位运算总结
date: 2019-6-25 11:06:00
categories: "位运算"
tags:
     - 位运算
---


### 二进制的一些概念

在二进制数里，最高位 0 表示正数，1 表示负数。

#### 原码
一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补 1，称为原码。

```
 5 的原码是：00000000 00000000 00000000 00000101
-5 的原码是：10000000 00000000 00000000 00000101
```

#### 反码
正数的反码与原码相同，负数的反码为对该数的原码**除符号位**外各位**取反**（即 0 变 1，1 变 0）。

```
正数 00000000 00000000 00000000 00000101 的反码还是 00000000 00000000 00000000 00000101
负数 10000000 00000000 00000000 00000101 的反码却是 11111111 11111111 11111111 11111010
```

#### 补码

正数的补码与原码相同，负数的补码为该数的反码加 1。

负数 10000000 00000000 00000000 00000101 的反码是 11111111 11111111 11111111 11111010，那么补码为：

```
11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011
```

### 位运算基础
基本的位操作符有与、或、异或、取反、左移、右移这 6 种，它们的运算规则如下所示：

|  符号 | 描述  | 运算规则  |
|:----:|:-----:|:---------|
| &    | 与    | 两个位都为 1 时，结果才为 1 |
| &#124;   | 或    | 两个位只要有一位为 1，结果都为 1 |
| ^    | 异或  | 两个位相同为 0，不同为 1 |
| ~    | 取反  | 0 变 1，1 变 0 |
| <<   | 左移  | 各二进位全部左移若干位，高位丢弃，低位补 0 |
| >>   | 右移  | 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移）|

**注意**

1. 在这 6 种操作符，只有 **~** 取反是单目操作符，其它 5 种都是双目操作符。

2. 位操作只能用于整形数据，对 float 和 double 类型进行位操作会被编译器报错。

3. 对于移位操作，在微软的 VC6.0 和 VS2008 编译器都是采取算术称位即算术移位操作，算术移位是相对于逻辑移位，它们在左移操作中都一样，低位补 0 即可，但在右移中逻辑移位的高位补 0 而算术移位的高位是补符号位。如下面代码会输出 -4 和 3。

   ```Java
   System.out.println((15) >> 2); // 3
   System.out.println((-15) >> 2); // -4
   ```
   15 = 00000000 00000000 00000000 00001111（二进制），右移二位，高位补 0，得到
   
   00000000 00000000 00000000 00000011 即 3。

   -15 = 11111111 11111111 11111111 11110001（二进制），右移二位，最高位由符号位填充，得到

   11111111 11111111 11111111 11111100 即 -4。

4. 位操作符的运算优先级比较低，因此应尽量使用括号来确保运算顺序。

5. 位操作还有一些复合操作符，如 &=、|=、 ^=、<<=、>>=。

### 常用的位运算技巧

#### 判断奇偶数
一个二进制数 x 的末位为 0 则该数为偶数，为 1 则为奇数，因此可以使用 (x & 1) 的结果来判断 x 的奇偶性，结果为 0，则 x 为偶数，结果为 1，则 x 为奇数。

如要求输出 0 到 10 之间的所有偶数：

```Java
for (int i = 0; i < 10; i++) {
    if ((i & 1) == 0) {
        System.out.println(i);
    }
}
```

#### 交换两数
```Java
int a = 10;
int b = 20;
a ^= b;
b ^= a;
a ^= b;
System.out.println("a=" + a); // a=20
System.out.println("b=" + b); // b=10
```

**分析：**

第一步，a = a ^ b ①；

第二步，b = b ^ a，把 ① 代入得，b = b ^ (a ^ b)，由于 **^ 满足交换律**，所以 b = b ^ b ^ a，根据「一个数和自己异或为 0，而 0 和任何数异或结果还是保持不变」的原理得，b = a ②；

第三步，a = a ^ b，将 ①、② 代入得，a = (a ^ b) ^ a 即 a = b ③。

从 ②、③ 得知，a 和 b 的值已经得到了交换。

#### 变换符号
一个数 x **取反加 1** 后就会变成 -x，即正数变为负数，负数变为正数。

```Java
int a = -5;
int b = 10;
a = ~a + 1;
b = ~b + 1;
System.out.println("a=" + a); // a=5
System.out.println("b=" + b); // b=-10
```

**分析：**

-5 = 11111111 11111111 11111111 11111011（二进制），取反再加 1 后变为：

00000000 00000000 00000000 00000101 = 5

> 注意：这里负数的取反是包括符号位的，不要和负数的反码混淆。

#### 求绝对值
对于正数，绝对值就是它本身，对于负数，直接取反加 1 就得到正数了，所以先判断一个整数的符号再做处理。对于整数 a，它的最高位为 0 代表正数，为 1 代表负数，我们对 a 右移 31 位得到一个整数 i（i = a >> 31），i 值为 0 代表 a 为正数，为 -1 代表 a 为负数。

```Java
private int abs(int a) {
    int i = a >> 31;
    return i == 0 ? a : (~a + 1);
}
```

进一步分析，对于任意整数 a，和 0（32 个 0）异或都保持不变，和 -1（32 个 1）异或相当于取反，所以上面的返回值可以转换为：

```Java
return i == 0 ? (a ^ i) : ((a ^ i) + 1);
```

上面返回值再变换下得：

```Java
return i == 0 ? ((a ^ i) - 0) : ((a ^ i) + 1);
```

由于 i 的值非 0 即 -1，因此上面返回值可以精简为：

```Java
return (a ^ i) - i;
```

通过上面的分析，我们得出求一个整数的绝对值的精简方式，这种方式不需任何判断。

```Java
private int abs(int a) {
    int i = a >> 31;
    return (a ^ i) - i;
}
```












