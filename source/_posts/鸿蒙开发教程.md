---
title: 鸿蒙开发教程
date: 2024-05-18 11:17:00
categories: "鸿蒙开发"
tags:
     - 鸿蒙开发
     - HarmonyOS

---

<meta name="referrer" content="no-referrer" />



### HarmonyOS 项目目录介绍

### ArkTS 基本语法详解

HarmonyOS 4.0 以后可以使用 ArkTS 或者 HTML/CSS/JS 技术来开发 HarmonyOS 应用，而 ArkTS 是 HarmonyOS 优选的主力应用开发语言。  

ArkTS 围绕应用开发在 TypeScript（简称 TS）生态基础上做了进一步扩展，继承了 TS 的所有特性，是 TS 的超集。因此，在学习 ArkTS 语言之前，建议首先具
备 TS 语言开发能力。

当前，ArkTS 在 TS 的基础上主要扩展了如下能力：

- **基本语法**：ArkTS 定义了声明式 UI 描述、自定义组件和动态扩展 UI 元素的能力，再配合 ArkUI 开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了 UI 开发的主体。
- **状态管理**：ArkTS 提供了多维度的状态管理机制。在 UI 开发框架中，与 UI 相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活的利用这些能力来实现数据和 UI 的联动。
- **渲染控制**：ArkTS 提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的 UI 内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。

未来，ArkTS 会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。  

#### ArkTS 基本组成

<img src="https://gitee.com/zch0304/images/raw/master/note/1716005497787.jpg" style="zoom:50%;" /> 

- **装饰器**： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中 @Entry、@Component 和 @State 都是装饰器，@Component 表示自定义组件，@Entry 表示该自定义组件为入口组件，@State 表示组件中的状态变量，状态变量变化会触发 UI 刷新。  
- **自定义组件**：可复用的 UI 单元，可组合其它组件，如上述被 @Component 装饰的 struct Index。  
- **UI 描述**：以声明式的方式来描述 UI 的结构，例如 build() 方法中的代码块  。
- **系统组件**：ArkUI 框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的 Column、Text、Divider、Button。  
- **事件方法**：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在 Button 后面的 onClick()。  
- **属性方法**：组件可以通过链式调用配置多项属性，如 fontSize()、width()、height()、backgroundColor() 等。  

系统组件、属性方法、事件方法具体使用可参考[基于 ArkTS 的声明式开发范式](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-components-summary-0000001478181369-V2)。

#### ArkTS 布局结构

布局的结构通常是分层级的，代表了用户界面中的整体架构。一个常见的页面结构如下所示：

<img src="https://gitee.com/zch0304/images/raw/master/note/1716013357130.jpg" style="zoom:50%;" /> 

为实现上述效果，需要在页面中声明对应的元素。其中，Page 表示页面的根节点，Column/Row 等元素为系统组件。针对不同的页面结构，ArkUI 提供了不同的布局组件来帮助我们实现对应布局的效果，例如 Row 用于实现线性布局等。  

#### ArkTS 数据类型

TypeScript 支持一些基础的数据类型，如布尔型、数组、字符串等。

##### 数字

TypeScript 里的所有数字都是浮点数，这些浮点数的类型是 `number`。除了支持十进制，还支持二进制、八进制、十六进制。  

```ts
// 数值类型
let num1: number = 18 // 十进制
let num2: number = 0b10111 // ob 二进制
let num3: number = 0o14 // 0o 八进制
let num4: number = 0x1f // 0x 十六进制
```

##### 字符串

TypeScript 里使用 `string` 表示文本数据类型， 可以使用双引号（ " ）或单引号（ ' ）表示字符串或者反引号（`）。

> 反引号中可以配合 ${} 解析变量。

```ts
// 字符串类型
let str1: string = 'HarmonyOS Next不支持Android 应用了'
let str2: string = "ArkTS"
let str3: string = `马总今年${num1}岁了`
```

##### 布尔值

TypeScript 中可以使用 `boolean` 来表示这个变量是布尔值，可以赋值为 true 或者 false。

```ts
// 布尔类型 true、false
let stateOn: boolean = true
let stateOff: boolean = false
```

##### 联合类型

联合类型（Union Types）表示取值可以为多种类型中的一种。如果一个数据可能有多重类型，或者当下还没想好用哪个类型 ...

```ts
let flag: string | number | boolean
flag = '1'
flag = 1
flag = true
```

##### 数组

TypeScrip 有两种方式可以定义数组。

```ts
// 第一种是使用数组泛型，Array<元素类型>。
let course1: Array<string> = ['Flutter', "HarmonyOS", `Golang`]

// 第二种是在元素类型后面接上 []，表示由此类型元素组成的一个数组。
let course2: string[] = ['Flutter', "HarmonyOS", `Golang`]
```

##### 枚举

enum 类型是对 JavaScript 标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字。

```ts
enum Color {Red, Green, Blue}
let c: Color = Color.Green
```

##### 元组

元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。

```ts
let x: [string, number]
x = ['hello', 10] // OK
x = [10, 'hello'] // Error
```

##### Any（不推荐使用）

any 类型，表示的是变量可以是任意类型，相当于关闭了 ts 的类型检测功能，不建议使用。如果是 any 类型，则允许被赋值为任意类型。

```ts
let a: any = 666
a = "Semlinker" // 通过，any 类型可以被赋任意值
a = false // 通过，any 类型可以被赋任意值
a = 66 // 通过，any 类型可以被赋任意值
a = undefined // 通过，any 类型可以被赋任意值
a = null // 通过，any 类型可以被赋任意值
a = [] // 通过，any 类型可以被赋任意值
a = {} // 通过，any 类型可以被赋任意值
```

##### Unknown

unknown 与 any 一样，也相当于关闭了 ts 的类型检测功能。有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。那么我们可以使用 unknown 类型来标记这些变量。（同 any ）。

 ```ts
let notSure: unknown = 4
notSure = 'maybe a string instead'
notSure = false
 ```

##### Void

当一个函数没有返回值时，你通常会见到其返回值类型是 void。

```ts
function test(): void {
  console.log('This is function is void')
}
```

##### Null 和 Undefined

TypeScript 里，null 和 undefined 两者各自有自己的类型分别叫做 null 和 undefined。  

```ts
let u: undefined = undefined
let n: null = null
```

#### ArkTS 渲染控制

##### if/else：条件渲染

- 支持 if、else 和 else if 语句。
- if、else if 后跟随的条件语句可以使用状态变量。
- 允许在容器组件内使用，通过条件渲染语句构建不同的子组件。
- 当 if、else if 后跟随的状态判断中使用的状态变量值变化时，条件渲染语句会进行更新条件可以包括 Typescript 表达式。

```ts
if (条件表达式) {
  组件内容1
} else {
  组件内容2
}
```

##### ForEach：循环渲染

ForEach 接口基于数组类型数据来进行循环渲染，需要与容器组件配合使用，且接口返回的组件应当是允许包含在 ForEach 父容器组件中的子组件。例如，ListItem 组件要求 ForEach 的父容器组件必须为 List 组件。

```ts
/**
 * @param arr 要遍历的数组
 * @param itemGenerator 页面的生成函数
 * @param keyGenerator 键生成函数，提供唯一标识，如果后续数组中数据发生变化，会判断元素的唯一标识是否发生变化，有变更再去做渲染，这样减少了不必要的渲染，提高了页面的渲染效率（可选参数，如果不填会会有默认的键生成函数，生成规则是用角标拼上数组元素的数据）
 */
ForEach(
  arr:Array<any>,
  itemGenerator:(item: any, index: number) => void,
  keyGenerator ? : (item: any, index: number) => string
)
```

```ts
let arr: number[] = [1, 2, 4, 8, 16]

@Entry
@Component
struct ArrayPage {
  
  arr2: string[] = ['HarmonyOS', 'Flutter', 'Android']

  build() {
    List({ space: 10 }) {
      // 访问全局变量 arr 不要加 this
      ForEach(arr, (item: number, key: number) => {
        ListItem() {
          Text(`${item}--${key}`)
            .fontSize(20)
            .width('100%')
            .height(50)
            .textAlign(TextAlign.Center)
            .backgroundColor("#eee")
            .borderRadius(10)
        }
      }, (item: number) => item.toString())

      // 访问局部变量 arr2 要加 this
      ForEach(this.arr2, (item: string) => {
        ListItem() {
          Text(item)
            .fontSize(20)
            .width('100%')
            .height(50)
            .textAlign(TextAlign.Center)
            .backgroundColor(Color.Gray)
            .borderRadius(10)
        }
      }, (item: string) => item)
    }.width('100%')
    .height('100%')
    .padding(10)
  }
}
```

> 实际开发中尽量不要使用全局变量，组件中使用全局变量不需要加 this。

##### LazyForEach：数据懒加载

LazyForEach 从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。当 LazyForEach 在滚动容器中使用，框架会根据滚动容器可视区域按需创建组件，当组件滑出可视区域外时，框架会进行组件销毁回收以降低内存占用。

### 布局组件

#### ArkTS 通用属性

ArkTS 通用属性用于设置组件的宽高、边距。

| 名称           | 参数说明                                                     | 描述                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| width          | Length                                                       | 设置组件自身的宽度，缺省时使用元素自身内容需要 的宽度。若子组件的宽大于父组件的宽，则会画出父 组件的范围。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| height         | Length                                                       | 设置组件自身的高度，缺省时使用元素自身内容需要 的高度。若子组件的高大于父组件的高，则会画出父 组件的范围。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| size           | {   width ? : Length,   height ? : Length }                  | 设置高宽尺寸。                                               |
| padding        | Padding &#124; Length                                        | 设置内边距属性。参数为 Length 类型时，四个方向内边距同时生效。默认值：0。padding 设置百分比时，上下左右内边距均以父容器的 width 作为基础值。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| margin         | Margin &#124; Length                                         | 设置外边距属性。参数为 Length 类型时，四个方向外边距同时生效。默认值：0。margin 设置百分比时，上下左右外边距均以父容器的 width 作为基础值。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| constraintSize | {   minWidth ? : Length,   maxWidth ? : Length,   minHeight ? : Length,   maxHeight ? : Length } | 设置约束尺寸，组件布局时，进行尺寸范围限制。 constraintSize 的优先级高于 Width 和 Height。若设置的 minWidth 大于 maxWidth，则 minWidth 生效， minHeight 与 maxHeight 同理。默认值：{   minWidth: 0, maxWidth:   Infinity, minHeight:   0, maxHeight:   Infinity }。 |

**Length 长度类型，用于描述尺寸单位。  **

| 类型     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| string   | 需要显式指定像素单位，如 '10px'，也可设置百分比字符串，如 '100%'。 |
| number   | 默认单位 vp。                                                |
| Resource | 资源引用类型，引入系统资源或者应用资源中的尺寸。             |

**vp 为虚拟像素单位**：vp 使用虚拟像素，使元素在不同密度的设备上具有一致的视觉体量。

**fp 字体像素单位**：字体像素（font pixel）大小默认情况下与 vp 相同，即默认情况下 1 fp = 1vp。如果用户在设置中选择了更大的字体，字体的实际显示大小就会在 vp 的基础上乘以用户设置的缩放系数，即 1 fp = 1 vp * 缩放系数。

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Row() {
        // 宽度 200，高度 200，外边距 20（蓝色区域），内边距 10（白色区域）
        Row() {
          Row().size({
            width: '100%', height: '100%'
          }).backgroundColor(Color.Yellow)
        }
        .width(200)
        .height(200)
        .padding(10)
        .margin(20)
        .backgroundColor(Color.White)
      }.backgroundColor(Color.Blue)

      Text(`This is a text.This is a text.This is a text.This is a text.This is a text`)
        .width('90%')
        .backgroundColor(Color.Orange)
        .constraintSize({ maxWidth: 200 })

      // 父容器尺寸确定时，设置了 layoutWeight 的子元素在主轴布局尺寸按照权重进行分配，忽略本身尺寸设置。
      Row() {
        // 权重 1，占主轴剩余空间 1/3
        Text('layoutWeight(1)')
          .size({ height: 110 })
          .backgroundColor(Color.Orange)
          .textAlign(TextAlign.Center)
          .layoutWeight(1)

        // 权重 2，占主轴剩余空间 2/3
        Text('layoutWeight(2)')
          .size({
            width: '30%', height: 110
          })
          .backgroundColor(Color.Green)
          .textAlign(TextAlign.Center)
          .layoutWeight(2)

        // 未设置 layoutWeight 属性，组件按照自身尺寸渲染
        Text('no layoutWeight')
          .size({
            width: '33%', height: 110
          })
          .backgroundColor(Color.Brown)
          .textAlign(TextAlign.Center)
      }.size({ width: '100%', height: 140 })
      .backgroundColor(0xCCCCCC)
    }
    .width('100%')
    .height('100%')
    .margin({ top: 5 })
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Start)
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716389533793.jpg" style="zoom:80%;" /> 

#### Column 详解

Column 是沿垂直方向布局的容器，可以包含多个子组件，多个子组件会在垂直方向上按照顺序排列。

##### Column 接口

```ts
Column(value?: {space?: string | number})
```

参数：

| 参数名 | 参数类型             | 必填 | 参数描述                                                     |
| ------ | -------------------- | ---- | ------------------------------------------------------------ |
| space  | string &#124; number | 否   | 纵向布局元素垂直方向间距。从 API version 9 开始，space 为负数或者 justifyContent 设置为 FlexAlign.SpaceBetween、 FlexAlign.SpaceAround、FlexAlign.SpaceEvenly 时不生效。默认值：0，单位 vp。说明：可选值为大于等于 0 的数字，或者可以转换为数字的字符串。 |

##### Column 属性

| 名称             | 参数类型        | 描述                                                         |
| ---------------- | --------------- | ------------------------------------------------------------ |
| alignItems       | HorizontalAlign | 设置子组件在水平方向上的对齐格式。默认值：HorizontalAlign.Center 从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| justifyContent8+ | FlexAlign       | 设置子组件在垂直方向上的对齐格式。默认值：FlexAlign.Start 从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Row() {
        Image($r('app.media.app_icon')).width(100).height(100)
      }
      .width(140)
      .height(140)
      .backgroundColor(Color.Red)
      .alignItems(VerticalAlign.Center)
      .justifyContent(FlexAlign.Center)
    }
    .width('100%')
    .height('100%')
    .margin({ top: 5 })
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Start)
  }
}
```

#### Row 详解

Row 为沿水平方向布局容器，可以包含多个子组件，多个子组件会在水平方向上按照顺序排列。

##### Row 接口

```ts
Row(value?: {space?: string | number})
```

参数：

| 参数 名 | 参数类 型            | 必 填 | 参数描述                                                     |
| ------- | -------------------- | ----- | ------------------------------------------------------------ |
| space   | string &#124; number | 否    | 横向布局元素间距。从 API version 9 开始，space 为负数或者 justifyContent 设置为 FlexAlign.SpaceBetween、FlexAlign.SpaceAround、FlexAlign.SpaceEvenly 时不生效。默认值：0，单位 vp。说明：可选值为大于等于 0 的数字，或者可以转换为 数字的字符串。 |

##### Row 属性

| 名称             | 参数类型      | 描述                                                         |
| ---------------- | ------------- | ------------------------------------------------------------ |
| alignItems       | VerticalAlign | 设置子组件在垂直方向上的对齐格式。默认值：VerticalAlign.Center 从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| justifyContent8+ | FlexAlign     | 设置子组件在水平方向上的对齐格式。默认值：FlexAlign.Start 从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |

#### 自定义组件

自定义组件传值。

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Container()
      Container({ color: Color.Orange, icon: $r('app.media.user') })
      Container({ color: Color.Brown, icon: $r('app.media.settings') })
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.SpaceBetween)
  }
}

@Component
struct Container {
  color: Color = Color.Red
  icon: Resource = $r('app.media.app_icon')

  build() {
    Row() {
      Image(this.icon).width(100).height(100)
    }
    .width(140)
    .height(140)
    .backgroundColor(this.color)
    .alignItems(VerticalAlign.Center)
    .justifyContent(FlexAlign.Center)
  }
}
```

#### Row、Column 结合 layoutWeight 实现弹性布局

ArkTS 中使用 Row、Column 结合 layoutWeight 属性可以实现弹性布局。

##### 水平弹性布局

```ts
@Entry
@Component
struct Index {
  build() {
    Row() {
      Row().height(100).backgroundColor(Color.Red).layoutWeight(1)
      Row().height(100).backgroundColor(Color.Green).layoutWeight(1)
      Row() {
        Text('no layoutWeight').textAlign(TextAlign.Center).width('100%')
      }.height(100).backgroundColor(Color.Orange).size({ height: 100, width: 200 })
    }.size({ width: '100%', height: 100 })
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716388652192.jpg) 

##### 垂直弹性布局

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Row() {
        Image("https://gitee.com/zch0304/images/raw/master/note/test_icon1.jpg").objectFit(ImageFit.Fill)
      }.size({ width: '100%', height: 160 })

      Row({ space: 10 }) {
        Row() {
          Image("https://gitee.com/zch0304/images/raw/master/note/test_icon2.jpg").objectFit(ImageFit.Fill)
        }.layoutWeight(2)
        
        Row() {
          Column({ space: 10 }) {
            Row() {
              Image("https://gitee.com/zch0304/images/raw/master/note/test_icon3.jpg").objectFit(ImageFit.Fill)
            }.layoutWeight(1).width('100%')

            Row() {
              Image("https://gitee.com/zch0304/images/raw/master/note/test_icon4.jpg").objectFit(ImageFit.Fill)
            }.layoutWeight(1).width('100%')
          }
        }.layoutWeight(1)
      }.size({ width: '100%', height: 140 })
    }
    .margin(5)
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716472510603.jpg) 

#### Stack 定位组件

Stack 组件可以实现容器堆叠，子组件按照顺序依次入栈，后一个子组件覆盖前一个子组件。

##### Stack 接口

```ts
Stack(value?: { alignContent?: Alignment })
```

参数：

| 参数名       | 参数类型  | 必 填 | 参数描述                                                 |
| ------------ | --------- | ----- | -------------------------------------------------------- |
| alignContent | Alignment | 否    | 设置子组件在容器内的对齐方式。默认值：Alignment.Center。 |

##### Stack 基本使用

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Stack({ alignContent: Alignment.BottomStart }) {
        Row() {
          Text("HarmonyOS").fontSize(40).textAlign(TextAlign.Center)
        }.width(300).height(300).backgroundColor(Color.Orange)

        Row().width(100).height(100).backgroundColor(Color.Blue)
      }
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Center)
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716473605745.jpg) 

##### Stack 子组件中 zIndex 控制层级

```ts
@Entry
@Component
struct Index {
  build() {
    Stack({ alignContent: Alignment.BottomStart }) {
      Column() {
        Text("Stack子元素1").fontSize(20)
      }.width(100).height(100).backgroundColor(Color.Orange).zIndex(2)

      Column() {
        Text("Stack子元素2").fontSize(20)
      }.width(150).height(150).backgroundColor(Color.Yellow).zIndex(1)

      Column() {
        Text("Stack子元素3").fontSize(20)
      }.width(200).height(200).backgroundColor(Color.Pink)
    }.width(350).height(350).backgroundColor(Color.Gray)
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716474425596.jpg) 

##### Stack 结合 List 实现动态列表

要实现的功能：
1、实现浮动按钮。
2、点击按钮让列表的数字加一。

```ts
@Entry
@Component
struct Index {
  @State list: number[] = [1, 2, 3]

  build() {
    Column() {
      Stack({ alignContent: Alignment.BottomEnd }) {
        List({ space: 10 }) {
          ForEach(this.list, (item: number) => {
            ListItem() {
              Text(`${item}`)
                .fontSize(20)
                .width('100%')
                .height(50)
                .backgroundColor('#eee')
                .textAlign(TextAlign.Center)
            }
          })
        }.width('100%').height('100%').padding(10)

        Button({ type: ButtonType.Circle, stateEffect: true }) {
          Text('+').fontSize(40).fontColor(Color.White)
        }.width(55).height(55).margin({ right: 20, bottom: 20 }).onClick(() => {
          this.doAdd()
        })
      }
    }.width('100%').height('100%').alignItems(HorizontalAlign.Center)
  }

  doAdd() {
    this.list.push(this.list[this.list.length-1] + 1)
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716475790377.jpg" style="zoom: 50%;" /> 

##### Stack 结合 List 实现浮动导航

```ts
@Entry
@Component
struct Index {
  @State list: number[] = [1, 2, 3]

  build() {
    Column() {
      Stack({ alignContent: Alignment.BottomEnd }) {
        Stack({ alignContent: Alignment.TopEnd }) {
          List({ space: 10 }) {
            ForEach(this.list, (item: number) => {
              ListItem() {
                Text(`${item}`)
                  .fontSize(20)
                  .width('100%')
                  .height(50)
                  .backgroundColor('#eee')
                  .textAlign(TextAlign.Center)
              }
            })
          }.width('100%').height('100%').padding({ left: 10, top: 70, right: 10, bottom: 10 })

          Row() {
            Text("导航").fontSize(16).textAlign(TextAlign.Center).width('100%')
          }.width('100%').height(60).backgroundColor(Color.Orange)
        }

        Button({ type: ButtonType.Circle, stateEffect: true }) {
          Text('+').fontSize(40).fontColor(Color.White)
        }.width(55).height(55).margin({ right: 20, bottom: 20 }).onClick(() => {
          this.doAdd()
        })
      }
    }.width('100%').height('100%').alignItems(HorizontalAlign.Center)
  }

  doAdd() {
    this.list.push(this.list[this.list.length-1] + 1)
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716477035040.jpg" style="zoom:50%;" /> 

#### 弹性布局（Flex）

Flex 弹性布局可以更加方便的对容器中的子元素进行排列、对齐和分配剩余空间等。单行的 Flex 跟 Row 组件的表现几乎一致，单列的 Flex 则跟 Column 组件表现几乎一致。但 Row 与 Column 都是单行单列的，Flex 则可以突破了这个限制，当主轴上空间不足时，则向纵轴上去扩展显示。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716554468902.jpg" style="zoom:50%;" /> 

##### Flex 接口

```ts
Flex(value?: { direction?: FlexDirection, wrap?: FlexWrap, justifyContent?: FlexAlign, alignItems?: ItemAlign, alignContent?: FlexAlign })
```

标准 Flex 布局容器。从 API version 9 开始，该接口支持在 ArkTS 片中使用。

##### Flex 参数

| 参数名         | 参数类型      | 必 填 | 默认值            | 参数描述                                                     |
| -------------- | ------------- | ----- | ----------------- | ------------------------------------------------------------ |
| direction      | FlexDirection | 否    | FlexDirection.Row | 子组件在 Flex 容器上排列的方向，即主轴的方向。               |
| wrap           | FlexWrap      | 否    | FlexWrap.NoWrap   | Flex 容器是单行/列还是多行/列排列。说明：在多行布局时，通过交叉轴方向，确认新行堆叠方向。 |
| justifyContent | FlexAlign     | 否    | FlexAlign.Start   | 子组件在 Flex 容器主轴上的对齐格式。                         |
| alignItems     | ItemAlign     | 否    | ItemAlign.Start   | 子组件在 Flex 容器交叉轴上的对齐格式。                       |
| alignContent   | FlexAlign     | 否    | FlexAlign.Start   | 交叉轴中有额外的空间时，多行内容的对齐方式。仅在 wrap 为 Wrap 或 WrapReverse 下生效。 |

##### Flex 轴的基本概念

- **主轴**：Flex 组件布局方向的轴线，子元素默认沿着主轴排列。主轴开始的位置称为主轴起始点，结束位置称为主轴结束点。
- **交叉轴**：垂直于主轴方向的轴线。交叉轴开始的位置称为交叉轴起始点，结束位置称为交叉轴结束点。

##### Flex 应用案例

弹性布局在开发场景中用例特别多，比如页面头部导航栏的均匀分布、页面框架的搭建、多行多列数据的排列等等。

 ##### direction 参数控制布局方向

Flex 布局中通过 direction 可以改变布局方向，在弹性布局中，容器的子元素可以按照任意方向排列。通过设置参数 direction，可以决定主轴的方向，从而控制子组件的排列方向。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716557181764.jpg" style="zoom:50%;" /> 

- FlexDirection.Row：主轴为水平方向，子组件从起始端沿着水平方向开始排布。
- FlexDirection.RowReverse：主轴为水平方向，子组件从终点端沿着 FlexDirection. Row 相反的方向开始排布。
- FlexDirection.Column：主轴为垂直方向，子组件从起始端沿着垂直方向开始排布。
- FlexDirection.ColumnReverse：主轴为垂直方向，子组件从终点端沿着 FlexDirection. Column 相反的方向开始排布。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ direction: FlexDirection.Row }) {
      Text('1').width('33%').height(50).backgroundColor(Color.Red)
      Text('2').width('33%').height(50).backgroundColor(Color.Green)
      Text('3').width('33%').height(50).backgroundColor(Color.Orange)
    }.width('90%').height(70).padding(10).backgroundColor('#ccc')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716557759593.jpg) 

##### wrap 参数控制布局换行

弹性布局分为单行布局和多行布局。默认情况下，Flex 容器中的子元素都排在一条线（又称“轴线”） 上。wrap 属性控制当子元素主轴尺寸之和大于容器主轴尺寸时，Flex 是单行布局还是多行布局。在多行布局时，通过交叉轴方向，确认新行堆叠方向。 

**FlexWrap. NoWrap**（默认值）：不换行。如果子组件的宽度总和大于父元素的宽度，则子组件会被压缩宽度。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ wrap: FlexWrap.NoWrap }) {
      Text('1').width('50%').height(50).backgroundColor(Color.Red)
      Text('2').width('50%').height(50).backgroundColor(Color.Green)
      Text('3').width('50%').height(50).backgroundColor(Color.Orange)
    }.width('90%').padding(10).backgroundColor('#ccc')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716557759593.jpg) 

**FlexWrap. Wrap**：换行，每一行子组件按照主轴方向排列。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ wrap: FlexWrap.Wrap }) {
      Text('1').width('50%').height(50).backgroundColor(Color.Red)
      Text('2').width('50%').height(50).backgroundColor(Color.Green)
      Text('3').width('50%').height(50).backgroundColor(Color.Orange)
    }.width('90%').padding(10).backgroundColor('#ccc')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716558674189.jpg) 

**FlexWrap. WrapReverse**：换行，每一行子组件按照主轴反方向排列。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ wrap: FlexWrap.WrapReverse }) {
      Text('1').width('50%').height(50).backgroundColor(Color.Red)
      Text('2').width('50%').height(50).backgroundColor(Color.Green)
      Text('3').width('50%').height(50).backgroundColor(Color.Orange)
    }.width('90%').padding(10).backgroundColor('#ccc')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716558853253.jpg" style="zoom:80%;" /> 

##### justifyContent 配置主轴对齐方式

<img src="https://gitee.com/zch0304/images/raw/master/note/1716559329865.jpg" style="zoom: 67%;" /> 

**FlexAlign.Start**（默认值）：子组件在主轴方向起始端对齐，第一个子组件与父元素边沿对齐，其他元素与前一个元素对齐。

**FlexAlign.Center**：子组件在主轴方向居中对齐。

**FlexAlign.End**：子组件在主轴方向终点端对齐，最后一个子组件与父元素边沿对齐，其它元素与后一个元素对齐。

**FlexAlign.SpaceBetween**：Flex 主轴方向均匀分配弹性元素，相邻子组件之间距离相同。第一个子组件和最后一个子组件与父元素边沿对齐。

**FlexAlign.SpaceAround**：Flex 主轴方向均匀分配弹性元素，相邻子组件之间距离相同。第一个子组件到主轴起始端的距离和最后一个子组件到主轴终点端的距离是相邻元素之间距离的一半。

**FlexAlign.SpaceEvenly**：Flex 主轴方向元素等间距布局，相邻子组件之间的间距、第一个子组件与主轴起始端的间距、最后一个子组件到主轴终点端的间距均相等。

##### alignContent 配置内容对齐

可以通过 alignContent 参数设置子组件各行在交叉轴剩余空间内的对齐方式，只在多行的 ﬂex 布局中生效（仅在 wrap 为 Wrap 或 WrapReverse 下生效），可选值有：

**FlexAlign.Start**：子组件各行与交叉轴起点对齐，默认值。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.Start }) {
      Text('1').width('30%').height(20).backgroundColor(Color.Red)
      Text('2').width('60%').height(20).backgroundColor(Color.Green)
      Text('3').width('40%').height(20).backgroundColor(Color.Orange)
      Text('4').width('30%').height(20).backgroundColor(Color.Pink)
      Text('5').width('20%').height(20).backgroundColor(Color.Yellow)
    }.height(100).backgroundColor('#ccc')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716561030772.jpg) 

**FlexAlign.Center**：子组件各行在交叉轴方向居中对齐。

![](https://gitee.com/zch0304/images/raw/master/note/1716561257608.jpg) 

**FlexAlign.End**：子组件各行与交叉轴终点对齐。

![](https://gitee.com/zch0304/images/raw/master/note/1716561389788.jpg) 

**FlexAlign.SpaceBetween**：子组件各行与交叉轴两端对齐，各行间垂直间距平均分布。

![](https://gitee.com/zch0304/images/raw/master/note/1716561544100.jpg) 

**FlexAlign.SpaceAround**：子组件各行间距相等，是元素首尾行与交叉轴两端距离的两倍。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716561707980.jpg" style="zoom:80%;" /> 

**FlexAlign.SpaceEvenly**：子组件各行间距，子组件首尾行与交叉轴两端距离都相等。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716561851381.jpg" style="zoom:80%;" /> 

##### alignItems 参数控制交叉轴对齐方式

容器和子元素都可以设置交叉轴对齐方式，且子元素设置的对齐方式优先级较高。可以通过 Flex 组件的 alignItems 参数设置子组件在交叉轴的对齐方式。

**ItemAlign.Auto**：使用 Flex 容器中默认配置。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ alignItems: ItemAlign.Auto }) {
      Text('1').width('33%').height(20).backgroundColor(Color.Red)
      Text('2').width('33%').height(40).backgroundColor(Color.Green)
      Text('3').width('33%').height(60).backgroundColor(Color.Orange)
    }.height(80).backgroundColor('#ccc')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716816140506.jpg" style="zoom:80%;" /> 

**ItemAlign.Start**：交叉轴方向首部对齐，默认值。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716816140506.jpg" style="zoom:80%;" /> 

**ItemAlign.Center**：交叉轴方向居中对齐。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716816486562.jpg" style="zoom:80%;" /> 

**ItemAlign.End**：交叉轴方向底部对齐。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716817062907.jpg" style="zoom:80%;" /> 

**ItemAlign.Stretch**：交叉轴方向拉伸填充，在未设置尺寸时，拉伸到容器尺寸。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716817484409.jpg" style="zoom:80%;" /> 

**ItemAlign. Baseline**：交叉轴方向文本基线对齐。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716817697841.jpg" style="zoom:80%;" /> 

##### Flex 自适应拉伸布局属性

Row、Column 结合 layoutWeight 可以实现自适应拉伸弹性布局。

**1、ﬂexGrow 属性**

设置父容器的剩余空间分配给此属性所在组件的比例。用于“瓜分”父组件的剩余空间。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex() {
      Text('1').flexGrow(1).height(60).backgroundColor(Color.Red)
      Text('2').flexGrow(2).height(60).backgroundColor(Color.Green)
      Text('no flexGrow').width(100).height(60).backgroundColor(Color.Orange)
    }.height(80).backgroundColor('#ccc')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716819203162.jpg" style="zoom:80%;" /> 

父容器宽度 400vp，三个子组件原始宽度为 100vp，总和 300vp，剩余空间 100vp 根据 ﬂexGrow 值的占比分配给子组件，未设置 ﬂexGrow 的子组件不参与“瓜分”。 第一个元素以及第二个元素以 2:3 分配剩下的 100vp。第一个元素为 100vp+100vp2/5=140vp，第 二个元素为 100vp+100vp3/5=160vp。

**2、ﬂexShrink 属性**

当父容器空间不足时，子组件的压缩比例。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex() {
      Text('flexShrink(3)').flexShrink(3).width(200).height(60).backgroundColor(Color.Red)
      Text('no flexShrink').width(200).height(60).backgroundColor(Color.Green)
      Text('flexShrink(1)').flexShrink(1).width(200).height(60).backgroundColor(Color.Orange)
    }.width(400).height(80).backgroundColor('#ccc')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716821744026.jpg" style="zoom:80%;" /> 





