---
title: 鸿蒙开发教程
date: 2024-05-18 11:17:00
categories: "鸿蒙开发"
tags:
     - 鸿蒙开发
     - HarmonyOS

---

<meta name="referrer" content="no-referrer" />



### HarmonyOS 项目目录介绍

### ArkTS 基本语法详解

HarmonyOS 4.0 以后可以使用 ArkTS 或者 HTML/CSS/JS 技术来开发 HarmonyOS 应用，而 ArkTS 是 HarmonyOS 优选的主力应用开发语言。  

ArkTS 围绕应用开发在 TypeScript（简称 TS）生态基础上做了进一步扩展，继承了 TS 的所有特性，是 TS 的超集。因此，在学习 ArkTS 语言之前，建议首先具
备 TS 语言开发能力。

当前，ArkTS 在 TS 的基础上主要扩展了如下能力：

- **基本语法**：ArkTS 定义了声明式 UI 描述、自定义组件和动态扩展 UI 元素的能力，再配合 ArkUI 开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了 UI 开发的主体。
- **状态管理**：ArkTS 提供了多维度的状态管理机制。在 UI 开发框架中，与 UI 相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活的利用这些能力来实现数据和 UI 的联动。
- **渲染控制**：ArkTS 提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的 UI 内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。

未来，ArkTS 会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。  

#### ArkTS 基本组成

<img src="https://gitee.com/zch0304/images/raw/master/note/1716005497787.jpg" style="zoom:50%;" /> 

- **装饰器**： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中 @Entry、@Component 和 @State 都是装饰器，@Component 表示自定义组件，@Entry 表示该自定义组件为入口组件，@State 表示组件中的状态变量，状态变量变化会触发 UI 刷新。  
- **自定义组件**：可复用的 UI 单元，可组合其它组件，如上述被 @Component 装饰的 struct Index。  
- **UI 描述**：以声明式的方式来描述 UI 的结构，例如 build() 方法中的代码块  。
- **系统组件**：ArkUI 框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的 Column、Text、Divider、Button。  
- **事件方法**：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在 Button 后面的 onClick()。  
- **属性方法**：组件可以通过链式调用配置多项属性，如 fontSize()、width()、height()、backgroundColor() 等。  

系统组件、属性方法、事件方法具体使用可参考[基于 ArkTS 的声明式开发范式](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-components-summary-0000001478181369-V2)。

#### ArkTS 布局结构

布局的结构通常是分层级的，代表了用户界面中的整体架构。一个常见的页面结构如下所示：

<img src="https://gitee.com/zch0304/images/raw/master/note/1716013357130.jpg" style="zoom:50%;" /> 

为实现上述效果，需要在页面中声明对应的元素。其中，Page 表示页面的根节点，Column/Row 等元素为系统组件。针对不同的页面结构，ArkUI 提供了不同的布局组件来帮助我们实现对应布局的效果，例如 Row 用于实现线性布局等。  

#### ArkTS 数据类型

TypeScript 支持一些基础的数据类型，如布尔型、数组、字符串等。

##### 数字

TypeScript 里的所有数字都是浮点数，这些浮点数的类型是 `number`。除了支持十进制，还支持二进制、八进制、十六进制。  

```ts
// 数值类型
let num1: number = 18 // 十进制
let num2: number = 0b10111 // ob 二进制
let num3: number = 0o14 // 0o 八进制
let num4: number = 0x1f // 0x 十六进制
```

##### 字符串

TypeScript 里使用 `string` 表示文本数据类型， 可以使用双引号（ " ）或单引号（ ' ）表示字符串或者反引号（`）。

> 反引号中可以配合 ${} 解析变量。

```ts
// 字符串类型
let str1: string = 'HarmonyOS Next不支持Android 应用了'
let str2: string = "ArkTS"
let str3: string = `马总今年${num1}岁了`
```

##### 布尔值

TypeScript 中可以使用 `boolean` 来表示这个变量是布尔值，可以赋值为 true 或者 false。

```ts
// 布尔类型 true、false
let stateOn: boolean = true
let stateOff: boolean = false
```

##### 联合类型

联合类型（Union Types）表示取值可以为多种类型中的一种。如果一个数据可能有多重类型，或者当下还没想好用哪个类型 ...

```ts
let flag: string | number | boolean
flag = '1'
flag = 1
flag = true
```

##### 数组

TypeScrip 有两种方式可以定义数组。

```ts
// 第一种是使用数组泛型，Array<元素类型>。
let course1: Array<string> = ['Flutter', "HarmonyOS", `Golang`]

// 第二种是在元素类型后面接上 []，表示由此类型元素组成的一个数组。
let course2: string[] = ['Flutter', "HarmonyOS", `Golang`]
```

##### 枚举

enum 类型是对 JavaScript 标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字。

```ts
enum Color {Red, Green, Blue}
let c: Color = Color.Green
```

##### 元组

元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。

```ts
let x: [string, number]
x = ['hello', 10] // OK
x = [10, 'hello'] // Error
```

##### Any（不推荐使用）

any 类型，表示的是变量可以是任意类型，相当于关闭了 ts 的类型检测功能，不建议使用。如果是 any 类型，则允许被赋值为任意类型。

```ts
let a: any = 666
a = "Semlinker" // 通过，any 类型可以被赋任意值
a = false // 通过，any 类型可以被赋任意值
a = 66 // 通过，any 类型可以被赋任意值
a = undefined // 通过，any 类型可以被赋任意值
a = null // 通过，any 类型可以被赋任意值
a = [] // 通过，any 类型可以被赋任意值
a = {} // 通过，any 类型可以被赋任意值
```

##### Unknown

unknown 与 any 一样，也相当于关闭了 ts 的类型检测功能。有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。那么我们可以使用 unknown 类型来标记这些变量。（同 any ）。

 ```ts
let notSure: unknown = 4
notSure = 'maybe a string instead'
notSure = false
 ```

##### Void

当一个函数没有返回值时，你通常会见到其返回值类型是 void。

```ts
function test(): void {
  console.log('This is function is void')
}
```

##### Null 和 Undefined

TypeScript 里，null 和 undefined 两者各自有自己的类型分别叫做 null 和 undefined。  

```ts
let u: undefined = undefined
let n: null = null
```

#### ArkTS 渲染控制

##### if/else：条件渲染

- 支持 if、else 和 else if 语句。
- if、else if 后跟随的条件语句可以使用状态变量。
- 允许在容器组件内使用，通过条件渲染语句构建不同的子组件。
- 当 if、else if 后跟随的状态判断中使用的状态变量值变化时，条件渲染语句会进行更新条件可以包括 Typescript 表达式。

```ts
if (条件表达式) {
  组件内容1
} else {
  组件内容2
}
```

##### ForEach：循环渲染

ForEach 接口基于数组类型数据来进行循环渲染，需要与容器组件配合使用，且接口返回的组件应当是允许包含在 ForEach 父容器组件中的子组件。例如，ListItem 组件要求 ForEach 的父容器组件必须为 List 组件。

```ts
/**
 * @param arr 要遍历的数组
 * @param itemGenerator 页面的生成函数
 * @param keyGenerator 键生成函数，提供唯一标识，如果后续数组中数据发生变化，会判断元素的唯一标识是否发生变化，有变更再去做渲染，这样减少了不必要的渲染，提高了页面的渲染效率（可选参数，如果不填会会有默认的键生成函数，生成规则是用角标拼上数组元素的数据）
 */
ForEach(
  arr:Array<any>,
  itemGenerator:(item: any, index: number) => void,
  keyGenerator ? : (item: any, index: number) => string
)
```

```ts
let arr: number[] = [1, 2, 4, 8, 16]

@Entry
@Component
struct ArrayPage {
  
  arr2: string[] = ['HarmonyOS', 'Flutter', 'Android']

  build() {
    List({ space: 10 }) {
      // 访问全局变量 arr 不要加 this
      ForEach(arr, (item: number, key: number) => {
        ListItem() {
          Text(`${item}--${key}`)
            .fontSize(20)
            .width('100%')
            .height(50)
            .textAlign(TextAlign.Center)
            .backgroundColor("#eee")
            .borderRadius(10)
        }
      }, (item: number) => item.toString())

      // 访问局部变量 arr2 要加 this
      ForEach(this.arr2, (item: string) => {
        ListItem() {
          Text(item)
            .fontSize(20)
            .width('100%')
            .height(50)
            .textAlign(TextAlign.Center)
            .backgroundColor(Color.Gray)
            .borderRadius(10)
        }
      }, (item: string) => item)
    }.width('100%')
    .height('100%')
    .padding(10)
  }
}
```

> 实际开发中尽量不要使用全局变量，组件中使用全局变量不需要加 this。

##### LazyForEach：数据懒加载

LazyForEach 从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。当 LazyForEach 在滚动容器中使用，框架会根据滚动容器可视区域按需创建组件，当组件滑出可视区域外时，框架会进行组件销毁回收以降低内存占用。

### 布局组件

#### ArkTS 通用属性

ArkTS 通用属性用于设置组件的宽高、边距。

| 名称           | 参数说明                                                     | 描述                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| width          | Length                                                       | 设置组件自身的宽度，缺省时使用元素自身内容需要 的宽度。若子组件的宽大于父组件的宽，则会画出父 组件的范围。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| height         | Length                                                       | 设置组件自身的高度，缺省时使用元素自身内容需要 的高度。若子组件的高大于父组件的高，则会画出父 组件的范围。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| size           | {   width ? : Length,   height ? : Length }                  | 设置高宽尺寸。                                               |
| padding        | Padding &#124; Length                                        | 设置内边距属性。参数为 Length 类型时，四个方向内边距同时生效。默认值：0。padding 设置百分比时，上下左右内边距均以父容器的 width 作为基础值。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| margin         | Margin &#124; Length                                         | 设置外边距属性。参数为 Length 类型时，四个方向外边距同时生效。默认值：0。margin 设置百分比时，上下左右外边距均以父容器的 width 作为基础值。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| constraintSize | {   minWidth ? : Length,   maxWidth ? : Length,   minHeight ? : Length,   maxHeight ? : Length } | 设置约束尺寸，组件布局时，进行尺寸范围限制。 constraintSize 的优先级高于 Width 和 Height。若设置的 minWidth 大于 maxWidth，则 minWidth 生效， minHeight 与 maxHeight 同理。默认值：{   minWidth: 0, maxWidth:   Infinity, minHeight:   0, maxHeight:   Infinity }。 |

**Length 长度类型，用于描述尺寸单位。**

| 类型     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| string   | 需要显式指定像素单位，如 '10px'，也可设置百分比字符串，如 '100%'。 |
| number   | 默认单位 vp。                                                |
| Resource | 资源引用类型，引入系统资源或者应用资源中的尺寸。             |

**vp 为虚拟像素单位**：vp 使用虚拟像素，使元素在不同密度的设备上具有一致的视觉体量。

**fp 字体像素单位**：字体像素（font pixel）大小默认情况下与 vp 相同，即默认情况下 1 fp = 1 vp。如果用户在设置中选择了更大的字体，字体的实际显示大小就会在 vp 的基础上乘以用户设置的缩放系数，即 1 fp = 1 vp * 缩放系数。

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Row() {
        // 宽度 200，高度 200，外边距 20（蓝色区域），内边距 10（白色区域）
        Row() {
          Row().size({
            width: '100%', height: '100%'
          }).backgroundColor(Color.Yellow)
        }
        .width(200)
        .height(200)
        .padding(10)
        .margin(20)
        .backgroundColor(Color.White)
      }.backgroundColor(Color.Blue)

      Text(`This is a text.This is a text.This is a text.This is a text.This is a text`)
        .width('90%')
        .backgroundColor(Color.Orange)
        .constraintSize({ maxWidth: 200 })

      // 父容器尺寸确定时，设置了 layoutWeight 的子元素在主轴布局尺寸按照权重进行分配，忽略本身尺寸设置。
      Row() {
        // 权重 1，占主轴剩余空间 1/3
        Text('layoutWeight(1)')
          .size({ height: 110 })
          .backgroundColor(Color.Orange)
          .textAlign(TextAlign.Center)
          .layoutWeight(1)

        // 权重 2，占主轴剩余空间 2/3
        Text('layoutWeight(2)')
          .size({
            width: '30%', height: 110
          })
          .backgroundColor(Color.Green)
          .textAlign(TextAlign.Center)
          .layoutWeight(2)

        // 未设置 layoutWeight 属性，组件按照自身尺寸渲染
        Text('no layoutWeight')
          .size({
            width: '33%', height: 110
          })
          .backgroundColor(Color.Brown)
          .textAlign(TextAlign.Center)
      }.size({ width: '100%', height: 140 })
      .backgroundColor(0xCCCCCC)
    }
    .width('100%')
    .height('100%')
    .margin({ top: 5 })
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Start)
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716389533793.jpg" style="zoom:80%;" /> 

#### Column 详解

Column 是沿垂直方向布局的容器，可以包含多个子组件，多个子组件会在垂直方向上按照顺序排列。

##### Column 接口

```ts
Column(value?: {space?: string | number})
```

参数：

| 参数名 | 参数类型             | 必填 | 参数描述                                                     |
| ------ | -------------------- | ---- | ------------------------------------------------------------ |
| space  | string &#124; number | 否   | 纵向布局元素垂直方向间距。从 API version 9 开始，space 为负数或者 justifyContent 设置为 FlexAlign.SpaceBetween、 FlexAlign.SpaceAround、FlexAlign.SpaceEvenly 时不生效。默认值：0，单位 vp。说明：可选值为大于等于 0 的数字，或者可以转换为数字的字符串。 |

##### Column 属性

| 名称             | 参数类型        | 描述                                                         |
| ---------------- | --------------- | ------------------------------------------------------------ |
| alignItems       | HorizontalAlign | 设置子组件在水平方向上的对齐格式。默认值：HorizontalAlign.Center 从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| justifyContent8+ | FlexAlign       | 设置子组件在垂直方向上的对齐格式。默认值：FlexAlign.Start 从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Row() {
        Image($r('app.media.app_icon')).width(100).height(100)
      }
      .width(140)
      .height(140)
      .backgroundColor(Color.Red)
      .alignItems(VerticalAlign.Center)
      .justifyContent(FlexAlign.Center)
    }
    .width('100%')
    .height('100%')
    .margin({ top: 5 })
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Start)
  }
}
```

#### Row 详解

Row 为沿水平方向布局容器，可以包含多个子组件，多个子组件会在水平方向上按照顺序排列。

##### Row 接口

```ts
Row(value?: {space?: string | number})
```

参数：

| 参数 名 | 参数类 型            | 必 填 | 参数描述                                                     |
| ------- | -------------------- | ----- | ------------------------------------------------------------ |
| space   | string &#124; number | 否    | 横向布局元素间距。从 API version 9 开始，space 为负数或者 justifyContent 设置为 FlexAlign.SpaceBetween、FlexAlign.SpaceAround、FlexAlign.SpaceEvenly 时不生效。默认值：0，单位 vp。说明：可选值为大于等于 0 的数字，或者可以转换为 数字的字符串。 |

##### Row 属性

| 名称             | 参数类型      | 描述                                                         |
| ---------------- | ------------- | ------------------------------------------------------------ |
| alignItems       | VerticalAlign | 设置子组件在垂直方向上的对齐格式。默认值：VerticalAlign.Center 从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| justifyContent8+ | FlexAlign     | 设置子组件在水平方向上的对齐格式。默认值：FlexAlign.Start 从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |

#### 自定义组件

自定义组件传值。

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Container()
      Container({ color: Color.Orange, icon: $r('app.media.user') })
      Container({ color: Color.Brown, icon: $r('app.media.settings') })
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.SpaceBetween)
  }
}

@Component
struct Container {
  color: Color = Color.Red
  icon: Resource = $r('app.media.app_icon')

  build() {
    Row() {
      Image(this.icon).width(100).height(100)
    }
    .width(140)
    .height(140)
    .backgroundColor(this.color)
    .alignItems(VerticalAlign.Center)
    .justifyContent(FlexAlign.Center)
  }
}
```

#### Row、Column 结合 layoutWeight 实现弹性布局

ArkTS 中使用 Row、Column 结合 layoutWeight 属性可以实现弹性布局。

##### 水平弹性布局

```ts
@Entry
@Component
struct Index {
  build() {
    Row() {
      Row().height(100).backgroundColor(Color.Red).layoutWeight(1)
      Row().height(100).backgroundColor(Color.Green).layoutWeight(1)
      Row() {
        Text('no layoutWeight').textAlign(TextAlign.Center).width('100%')
      }.height(100).backgroundColor(Color.Orange).size({ height: 100, width: 200 })
    }.size({ width: '100%', height: 100 })
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716388652192.jpg) 

##### 垂直弹性布局

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Row() {
        Image("https://gitee.com/zch0304/images/raw/master/note/test_icon1.jpg").objectFit(ImageFit.Fill)
      }.size({ width: '100%', height: 160 })

      Row({ space: 10 }) {
        Row() {
          Image("https://gitee.com/zch0304/images/raw/master/note/test_icon2.jpg").objectFit(ImageFit.Fill)
        }.layoutWeight(2)
        
        Row() {
          Column({ space: 10 }) {
            Row() {
              Image("https://gitee.com/zch0304/images/raw/master/note/test_icon3.jpg").objectFit(ImageFit.Fill)
            }.layoutWeight(1).width('100%')

            Row() {
              Image("https://gitee.com/zch0304/images/raw/master/note/test_icon4.jpg").objectFit(ImageFit.Fill)
            }.layoutWeight(1).width('100%')
          }
        }.layoutWeight(1)
      }.size({ width: '100%', height: 140 })
    }
    .margin(5)
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716472510603.jpg) 

#### Stack 定位组件

Stack 组件可以实现容器堆叠，子组件按照顺序依次入栈，后一个子组件覆盖前一个子组件。

##### Stack 接口

```ts
Stack(value?: { alignContent?: Alignment })
```

参数：

| 参数名       | 参数类型  | 必 填 | 参数描述                                                 |
| ------------ | --------- | ----- | -------------------------------------------------------- |
| alignContent | Alignment | 否    | 设置子组件在容器内的对齐方式。默认值：Alignment.Center。 |

##### Stack 基本使用

```ts
@Entry
@Component
struct Index {
  build() {
    Column({ space: 10 }) {
      Stack({ alignContent: Alignment.BottomStart }) {
        Row() {
          Text("HarmonyOS").fontSize(40).textAlign(TextAlign.Center)
        }.width(300).height(300).backgroundColor(Color.Orange)

        Row().width(100).height(100).backgroundColor(Color.Blue)
      }
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Center)
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716473605745.jpg) 

##### Stack 子组件中 zIndex 控制层级

```ts
@Entry
@Component
struct Index {
  build() {
    Stack({ alignContent: Alignment.BottomStart }) {
      Column() {
        Text("Stack子元素1").fontSize(20)
      }.width(100).height(100).backgroundColor(Color.Orange).zIndex(2)

      Column() {
        Text("Stack子元素2").fontSize(20)
      }.width(150).height(150).backgroundColor(Color.Yellow).zIndex(1)

      Column() {
        Text("Stack子元素3").fontSize(20)
      }.width(200).height(200).backgroundColor(Color.Pink)
    }.width(350).height(350).backgroundColor(Color.Gray)
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716474425596.jpg) 

##### Stack 结合 List 实现动态列表

要实现的功能：
1、实现浮动按钮。
2、点击按钮让列表的数字加一。

```ts
@Entry
@Component
struct Index {
  @State list: number[] = [1, 2, 3]

  build() {
    Column() {
      Stack({ alignContent: Alignment.BottomEnd }) {
        List({ space: 10 }) {
          ForEach(this.list, (item: number) => {
            ListItem() {
              Text(`${item}`)
                .fontSize(20)
                .width('100%')
                .height(50)
                .backgroundColor('#eee')
                .textAlign(TextAlign.Center)
            }
          })
        }.width('100%').height('100%').padding(10)

        Button({ type: ButtonType.Circle, stateEffect: true }) {
          Text('+').fontSize(40).fontColor(Color.White)
        }.width(55).height(55).margin({ right: 20, bottom: 20 }).onClick(() => {
          this.doAdd()
        })
      }
    }.width('100%').height('100%').alignItems(HorizontalAlign.Center)
  }

  doAdd() {
    this.list.push(this.list[this.list.length-1] + 1)
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716475790377.jpg" style="zoom: 50%;" /> 

##### Stack 结合 List 实现浮动导航

```ts
@Entry
@Component
struct Index {
  @State list: number[] = [1, 2, 3]

  build() {
    Column() {
      Stack({ alignContent: Alignment.BottomEnd }) {
        Stack({ alignContent: Alignment.TopEnd }) {
          List({ space: 10 }) {
            ForEach(this.list, (item: number) => {
              ListItem() {
                Text(`${item}`)
                  .fontSize(20)
                  .width('100%')
                  .height(50)
                  .backgroundColor('#eee')
                  .textAlign(TextAlign.Center)
              }
            })
          }.width('100%').height('100%').padding({ left: 10, top: 70, right: 10, bottom: 10 })

          Row() {
            Text("导航").fontSize(16).textAlign(TextAlign.Center).width('100%')
          }.width('100%').height(60).backgroundColor(Color.Orange)
        }

        Button({ type: ButtonType.Circle, stateEffect: true }) {
          Text('+').fontSize(40).fontColor(Color.White)
        }.width(55).height(55).margin({ right: 20, bottom: 20 }).onClick(() => {
          this.doAdd()
        })
      }
    }.width('100%').height('100%').alignItems(HorizontalAlign.Center)
  }

  doAdd() {
    this.list.push(this.list[this.list.length-1] + 1)
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716477035040.jpg" style="zoom:50%;" /> 

#### 弹性布局（Flex）

Flex 弹性布局可以更加方便的对容器中的子元素进行排列、对齐和分配剩余空间等。单行的 Flex 跟 Row 组件的表现几乎一致，单列的 Flex 则跟 Column 组件表现几乎一致。但 Row 与 Column 都是单行单列的，Flex 则可以突破了这个限制，当主轴上空间不足时，则向纵轴上去扩展显示。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716554468902.jpg" style="zoom:50%;" /> 

##### Flex 接口

```ts
Flex(value?: { direction?: FlexDirection, wrap?: FlexWrap, justifyContent?: FlexAlign, alignItems?: ItemAlign, alignContent?: FlexAlign })
```

标准 Flex 布局容器。从 API version 9 开始，该接口支持在 ArkTS 片中使用。

##### Flex 参数

| 参数名         | 参数类型      | 必 填 | 默认值            | 参数描述                                                     |
| -------------- | ------------- | ----- | ----------------- | ------------------------------------------------------------ |
| direction      | FlexDirection | 否    | FlexDirection.Row | 子组件在 Flex 容器上排列的方向，即主轴的方向。               |
| wrap           | FlexWrap      | 否    | FlexWrap.NoWrap   | Flex 容器是单行/列还是多行/列排列。说明：在多行布局时，通过交叉轴方向，确认新行堆叠方向。 |
| justifyContent | FlexAlign     | 否    | FlexAlign.Start   | 子组件在 Flex 容器主轴上的对齐格式。                         |
| alignItems     | ItemAlign     | 否    | ItemAlign.Start   | 子组件在 Flex 容器交叉轴上的对齐格式。                       |
| alignContent   | FlexAlign     | 否    | FlexAlign.Start   | 交叉轴中有额外的空间时，多行内容的对齐方式。仅在 wrap 为 Wrap 或 WrapReverse 下生效。 |

##### Flex 轴的基本概念

- **主轴**：Flex 组件布局方向的轴线，子元素默认沿着主轴排列。主轴开始的位置称为主轴起始点，结束位置称为主轴结束点。
- **交叉轴**：垂直于主轴方向的轴线。交叉轴开始的位置称为交叉轴起始点，结束位置称为交叉轴结束点。



 ##### direction 参数控制布局方向

Flex 布局中通过 direction 可以改变布局方向，在弹性布局中，容器的子元素可以按照任意方向排列。通过设置参数 direction，可以决定主轴的方向，从而控制子组件的排列方向。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716557181764.jpg" style="zoom:50%;" /> 

- FlexDirection.Row：主轴为水平方向，子组件从起始端沿着水平方向开始排布。
- FlexDirection.RowReverse：主轴为水平方向，子组件从终点端沿着 FlexDirection. Row 相反的方向开始排布。
- FlexDirection.Column：主轴为垂直方向，子组件从起始端沿着垂直方向开始排布。
- FlexDirection.ColumnReverse：主轴为垂直方向，子组件从终点端沿着 FlexDirection. Column 相反的方向开始排布。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ direction: FlexDirection.Row }) {
      Text('1').width('33%').height(50).backgroundColor(Color.Red)
      Text('2').width('33%').height(50).backgroundColor(Color.Green)
      Text('3').width('33%').height(50).backgroundColor(Color.Orange)
    }.width('90%').height(70).padding(10).backgroundColor('#ccc')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716557759593.jpg) 

##### wrap 参数控制布局换行

弹性布局分为单行布局和多行布局。默认情况下，Flex 容器中的子元素都排在一条线（又称“轴线”） 上。wrap 属性控制当子元素主轴尺寸之和大于容器主轴尺寸时，Flex 是单行布局还是多行布局。在多行布局时，通过交叉轴方向，确认新行堆叠方向。 

**FlexWrap. NoWrap**（默认值）：不换行。如果子组件的宽度总和大于父元素的宽度，则子组件会被压缩宽度。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ wrap: FlexWrap.NoWrap }) {
      Text('1').width('50%').height(50).backgroundColor(Color.Red)
      Text('2').width('50%').height(50).backgroundColor(Color.Green)
      Text('3').width('50%').height(50).backgroundColor(Color.Orange)
    }.width('90%').padding(10).backgroundColor('#ccc')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716557759593.jpg) 

**FlexWrap. Wrap**：换行，每一行子组件按照主轴方向排列。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ wrap: FlexWrap.Wrap }) {
      Text('1').width('50%').height(50).backgroundColor(Color.Red)
      Text('2').width('50%').height(50).backgroundColor(Color.Green)
      Text('3').width('50%').height(50).backgroundColor(Color.Orange)
    }.width('90%').padding(10).backgroundColor('#ccc')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716558674189.jpg) 

**FlexWrap. WrapReverse**：换行，每一行子组件按照主轴反方向排列。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ wrap: FlexWrap.WrapReverse }) {
      Text('1').width('50%').height(50).backgroundColor(Color.Red)
      Text('2').width('50%').height(50).backgroundColor(Color.Green)
      Text('3').width('50%').height(50).backgroundColor(Color.Orange)
    }.width('90%').padding(10).backgroundColor('#ccc')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716558853253.jpg" style="zoom:80%;" /> 

##### justifyContent 配置主轴对齐方式

<img src="https://gitee.com/zch0304/images/raw/master/note/1716559329865.jpg" style="zoom: 67%;" /> 

**FlexAlign.Start**（默认值）：子组件在主轴方向起始端对齐，第一个子组件与父元素边沿对齐，其他元素与前一个元素对齐。

**FlexAlign.Center**：子组件在主轴方向居中对齐。

**FlexAlign.End**：子组件在主轴方向终点端对齐，最后一个子组件与父元素边沿对齐，其它元素与后一个元素对齐。

**FlexAlign.SpaceBetween**：Flex 主轴方向均匀分配弹性元素，相邻子组件之间距离相同。第一个子组件和最后一个子组件与父元素边沿对齐。

**FlexAlign.SpaceAround**：Flex 主轴方向均匀分配弹性元素，相邻子组件之间距离相同。第一个子组件到主轴起始端的距离和最后一个子组件到主轴终点端的距离是相邻元素之间距离的一半。

**FlexAlign.SpaceEvenly**：Flex 主轴方向元素等间距布局，相邻子组件之间的间距、第一个子组件与主轴起始端的间距、最后一个子组件到主轴终点端的间距均相等。

##### alignContent 配置内容对齐

可以通过 alignContent 参数设置子组件各行在交叉轴剩余空间内的对齐方式，只在多行的 ﬂex 布局中生效（仅在 wrap 为 Wrap 或 WrapReverse 下生效），可选值有：

**FlexAlign.Start**：子组件各行与交叉轴起点对齐，默认值。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.Start }) {
      Text('1').width('30%').height(20).backgroundColor(Color.Red)
      Text('2').width('60%').height(20).backgroundColor(Color.Green)
      Text('3').width('40%').height(20).backgroundColor(Color.Orange)
      Text('4').width('30%').height(20).backgroundColor(Color.Pink)
      Text('5').width('20%').height(20).backgroundColor(Color.Yellow)
    }.height(100).backgroundColor('#ccc')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1716561030772.jpg) 

**FlexAlign.Center**：子组件各行在交叉轴方向居中对齐。

![](https://gitee.com/zch0304/images/raw/master/note/1716561257608.jpg) 

**FlexAlign.End**：子组件各行与交叉轴终点对齐。

![](https://gitee.com/zch0304/images/raw/master/note/1716561389788.jpg) 

**FlexAlign.SpaceBetween**：子组件各行与交叉轴两端对齐，各行间垂直间距平均分布。

![](https://gitee.com/zch0304/images/raw/master/note/1716561544100.jpg) 

**FlexAlign.SpaceAround**：子组件各行间距相等，是元素首尾行与交叉轴两端距离的两倍。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716561707980.jpg" style="zoom:80%;" /> 

**FlexAlign.SpaceEvenly**：子组件各行间距，子组件首尾行与交叉轴两端距离都相等。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716561851381.jpg" style="zoom:80%;" /> 

##### alignItems 参数控制交叉轴对齐方式

容器和子元素都可以设置交叉轴对齐方式，且子元素设置的对齐方式优先级较高。可以通过 Flex 组件的 alignItems 参数设置子组件在交叉轴的对齐方式。

**ItemAlign.Auto**：使用 Flex 容器中默认配置。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex({ alignItems: ItemAlign.Auto }) {
      Text('1').width('33%').height(20).backgroundColor(Color.Red)
      Text('2').width('33%').height(40).backgroundColor(Color.Green)
      Text('3').width('33%').height(60).backgroundColor(Color.Orange)
    }.height(80).backgroundColor('#ccc')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716816140506.jpg" style="zoom:80%;" /> 

**ItemAlign.Start**：交叉轴方向首部对齐，默认值。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716816140506.jpg" style="zoom:80%;" /> 

**ItemAlign.Center**：交叉轴方向居中对齐。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716816486562.jpg" style="zoom:80%;" /> 

**ItemAlign.End**：交叉轴方向底部对齐。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716817062907.jpg" style="zoom:80%;" /> 

**ItemAlign.Stretch**：交叉轴方向拉伸填充，在未设置尺寸时，拉伸到容器尺寸。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716817484409.jpg" style="zoom:80%;" /> 

**ItemAlign. Baseline**：交叉轴方向文本基线对齐。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716817697841.jpg" style="zoom:80%;" /> 

##### Flex 自适应拉伸布局属性

Row、Column 结合 layoutWeight 可以实现自适应拉伸弹性布局。

**1、ﬂexGrow 属性**

设置父容器的剩余空间分配给此属性所在组件的比例。用于“瓜分”父组件的剩余空间。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex() {
      Text('1').flexGrow(1).height(60).backgroundColor(Color.Red)
      Text('2').flexGrow(2).height(60).backgroundColor(Color.Green)
      Text('no flexGrow').width(100).height(60).backgroundColor(Color.Orange)
    }.height(80).backgroundColor('#ccc')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716819203162.jpg" style="zoom:80%;" /> 

父容器宽度 400vp，三个子组件原始宽度为 100vp，总和 300vp，剩余空间 100vp 根据 ﬂexGrow 值的占比分配给子组件，未设置 ﬂexGrow 的子组件不参与“瓜分”。 第一个元素以及第二个元素以 2:3 分配剩下的 100vp。第一个元素为 100vp+100vp2/5=140vp，第 二个元素为 100vp+100vp3/5=160vp。

**2、ﬂexShrink 属性**

当父容器空间不足时，子组件的压缩比例。

```ts
@Entry
@Component
struct Index {
  build() {
    Flex() {
      Text('flexShrink(3)').flexShrink(3).width(200).height(60).backgroundColor(Color.Red)
      Text('no flexShrink').width(200).height(60).backgroundColor(Color.Green)
      Text('flexShrink(1)').flexShrink(1).width(200).height(60).backgroundColor(Color.Orange)
    }.width(400).height(80).backgroundColor('#ccc')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716821744026.jpg" style="zoom:80%;" /> 

##### Flex 应用案例

弹性布局在开发场景中用例特别多，比如页面头部导航栏的均匀分布、页面框架的搭建、多行多列数据的排列等等。

**1、热搜功能**

```ts
@Entry
@Component
struct Index {
  @State hotSearch: string[] = ['乒乓球', 'NBA直播', '世界杯', '广东城际铁路', 'Flutter教程', 'HarmonyOS', 'ArkTS']

  build() {
    Column() {
      Text('热门搜索')
        .fontSize(30)
        .fontWeight(FontWeight.Bold)
        .width('100%')
        .textAlign(TextAlign.Start)
        .padding(10)
        .fontColor('#666')
      Flex({ wrap: FlexWrap.Wrap }) {
        ForEach(this.hotSearch, (item: string) => {
          Text(`${item}`)
            .fontSize(18)
            .backgroundColor('#eee')
            .padding({ left: 16, top: 10, right: 16, bottom: 10 })
            .margin(10)
            .borderRadius(12)
        }, (item: string) => item)
      }
    }.width('100%').height('100%')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716910862339.jpg" style="zoom:80%;" /> 

**2、帮助列表**

```ts
interface HelpListInterface {
  title: string,
  icon: Resource
}

@Entry
@Component
struct Index {
  @State helpList: HelpListInterface[] = [
    {
      title: "我的订阅",
      icon: $r("app.media.subscribe")
    },
    {
      title: "常见问题",
      icon: $r("app.media.problem")
    },
    {
      title: "在线客服",
      icon: $r("app.media.customer_service")
    },
    {
      title: "意见反馈",
      icon: $r("app.media.opinion")
    },
    {
      title: "关怀模式",
      icon: $r("app.media.give")
    },
    {
      title: "会员中心",
      icon: $r("app.media.user")
    }
  ]

  build() {
    Column() {
      Flex({ wrap: FlexWrap.Wrap }) {
        ForEach(this.helpList, (item: HelpListInterface) => {
          Column() {
            Image(item.icon).width(42).height(42)
            Text(`${item.title}`).fontSize(15).fontColor('#666').padding({ top: 10 })
          }.width('25%').padding(5).margin({ bottom: 10 })
        }, (item: HelpListInterface) => item.title)
      }
      .margin(10)
      .backgroundColor('#fff')
      .borderRadius(10)
      .padding({ top: 15, bottom: 5 })
    }.width('100%').height('100%').backgroundColor('#eee')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716912172452.jpg" style="zoom:80%;" /> 

#### 相对布局（RelativeContainer）

相对布局组件，用于复杂场景中元素对齐的布局。

RelativeContainer 就是采用相对布局的容器，支持容器内部的子元素设置相对位置关系。子元素支持指定兄弟元素作为锚点，也支持指定父容器作为锚点，基于锚点做相对位置布局。下图是一个 RelativeContainer 的概念图，图中的虚线表示位置的依赖关系。

<img src="https://gitee.com/zch0304/images/raw/master/note/1716991550056.jpg" style="zoom: 33%;" /> 

##### 规则说明

1、容器内子组件区分水平方向，垂直方向：

​    （1）水平方向为 left，middle，right，对应容器的 HorizontalAlign.Start，HorizontalAlign.Center，HorizontalAlign.End。

​    （2）垂直方向为 top，center，bottom，对应容器的 VerticalAlign.Top，VerticalAlign.Center，VerticalAlign.Bottom。

2、子组件可以将容器或者其他子组件设为锚点：

​    （1）参与相对布局的容器内组件必须设置 id，不设置 id 的组件不显示，RelativeContainer 容器的固定 id 为 \_\_container\_\_。

​    （2）此子组件某一方向上的三个位置可以将容器或其它子组件的同方向三个位置为锚点，同方向上两个以上位置设置锚点以后会跳过第三个。

​    （3）前端页面设置的子组件尺寸大小不会受到相对布局规则的影响。子组件某个方向上设置两个或以上 alignRules 时不建议设置此方向尺寸大小。

​    （4）对齐后需要额外偏移可设置 **oﬀset**。

3、特殊情况：

​    （1）互相依赖，环形依赖时容器内子组件全部不绘制。

​    （2）同方向上两个以上位置设置锚点但锚点位置逆序时，此子组件大小为 0，即不绘制。

​    （3）容器不设置宽高时，容器与容器内子组件不绘制。

##### 基本使用演示

```tsx
@Entry
@Component
struct Index {
  build() {
    Column() {
      RelativeContainer() {
        Row()
          .width(100)
          .height(100)
          .backgroundColor(Color.Orange)
          .alignRules({
            left: { anchor: '__container__', align: HorizontalAlign.Start },
            top: { anchor: '__container__', align: VerticalAlign.Top }
          })
          .id('row1')
          .offset({ x: 20, y: 20 })
      }.width(200).height(200).border({ width: 2, color: Color.Green }).id('rc')
    }.width('100%').height('100%')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1716995097983.jpg" style="zoom:80%;" /> 

```tsx
@Entry
@Component
struct Index {
  build() {
    RelativeContainer() {
      Text('1')
        .id('text1')
        .width(100)
        .height(100)
        .fontSize(30)
        .textAlign(TextAlign.Center)
        .backgroundColor(Color.Red)
        .alignRules({
          top: { anchor: '__container__', align: VerticalAlign.Top },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
      Text('2')
        .id('text2')
        .width(100)
        .height(100)
        .fontSize(30)
        .textAlign(TextAlign.Center)
        .backgroundColor(Color.Green)
        .alignRules({
          top: { anchor: 'text1', align: VerticalAlign.Bottom },
          right: { anchor: 'text1', align: HorizontalAlign.Start }
        })
      Text('3')
        .id('text3')
        .width(100)
        .height(100)
        .fontSize(30)
        .textAlign(TextAlign.Center)
        .backgroundColor(Color.Blue)
        .alignRules({
          top: { anchor: 'text1', align: VerticalAlign.Bottom },
          left: { anchor: 'text1', align: HorizontalAlign.Start }
        })
      Text('4')
        .id('text4')
        .width(100)
        .height(100)
        .fontSize(30)
        .textAlign(TextAlign.Center)
        .backgroundColor(Color.Yellow)
        .alignRules({
          top: { anchor: 'text1', align: VerticalAlign.Bottom },
          left: { anchor: 'text1', align: HorizontalAlign.End }
        })
      Text('5')
        .id('text5')
        .width(100)
        .height(100)
        .fontSize(30)
        .textAlign(TextAlign.Center)
        .backgroundColor(Color.Pink)
        .alignRules({
          top: { anchor: 'text3', align: VerticalAlign.Bottom },
          left: { anchor: 'text3', align: HorizontalAlign.Start }
        })
    }
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1717678884319.jpg" style="zoom:80%;" /> 

##### 实现底部弹出按钮案例

```tsx
@Entry
@Component
struct Index {
  @State flag: boolean = false

  build() {
    Column() {
      Stack({ alignContent: Alignment.BottomEnd }) {
        List({ space: 10 }) {
          ForEach([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (item: number) => {
            ListItem() {
              Text(`${item}`)
                .fontSize(30)
                .width('100%')
                .height(80)
                .backgroundColor('#eee')
                .borderRadius(10)
                .textAlign(TextAlign.Center)
            }
          })
        }.width('100%').height('100%').padding(10)

        RelativeContainer() {
          Button({ stateEffect: true }) {
            Text('+').textAlign(TextAlign.Center).fontColor(Color.White).fontSize(30)
          }
          .id('add')
          .width(80)
          .height(80)
          .alignRules({
            top: { anchor: '__container__', align: VerticalAlign.Top },
            left: { anchor: '__container__', align: HorizontalAlign.Start }
          })

          if (this.flag) {
            Button() {
              Text('A').textAlign(TextAlign.Center).fontColor(Color.White).fontSize(30)
            }
            .id('A')
            .width(80)
            .height(80)
            .backgroundColor(Color.Orange)
            .alignRules({
              bottom: { anchor: 'add', align: VerticalAlign.Top },
              right: { anchor: 'add', align: HorizontalAlign.End }
            })
            .offset({ y: -30 })
            .opacity(0.8)

            Button() {
              Text('B').textAlign(TextAlign.Center).fontColor(Color.White).fontSize(30)
            }
            .id('B')
            .width(80)
            .height(80)
            .backgroundColor(Color.Gray)
            .alignRules({
              bottom: { anchor: 'add', align: VerticalAlign.Top },
              right: { anchor: 'add', align: HorizontalAlign.Start }
            })
            .offset({ x: -10, y: -10 })
            .opacity(0.8)

            Button() {
              Text('C').textAlign(TextAlign.Center).fontColor(Color.White).fontSize(30)
            }
            .id('C')
            .width(80)
            .height(80)
            .backgroundColor(Color.Green)
            .alignRules({
              top: { anchor: 'add', align: VerticalAlign.Top },
              right: { anchor: 'add', align: HorizontalAlign.Start }
            })
            .offset({ x: -30 })
            .opacity(0.8)
          }

        }
        .width(88)
        .height(88)
        .onClick(() => {
          this.flag = !this.flag
        })
      }
    }
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1717682221884.jpg" style="zoom:80%;" /> 

#### Image 图片组件以及 HarmonyOS 图标库

Image 图片组件，支持本地图片和网络图片的渲染展示。

##### 加载网络图片

1、需要在 src/main/module.json5 中申请网络权限。

```json
"requestPermissions": [
 {
    "name": "ohos.permission.INTERNET"
 }
]
```

2、加载远程图片。

```tsx
Image('https://gitee.com/zch0304/images/raw/master/note/test_icon1.jpg')
```

##### 加载本地图片

```tsx
// resources\base\media 目录
Image($r('app.media.startIcon')).width(100).height(100).margin(10)

// resources\rawfile 目录
Image($rawfile('img.png')).width(100).height(100).margin(10)
```

##### HarmonyOS 图标库

https://developer.harmonyos.com/cn/design/harmonyos-icon/

https://www.iconfont.cn/

#### List 组件详解

List 适合用于呈现同类数据类型或数据类型集，例如图片和文本。在列表中显示数据集合是许多应用程序中的常见要求（如通讯录、音乐列表、购物清单等）。

List 包含 ListItem、ListItemGroup 子组件。

##### List 接口

```tsx
List(value?:{space?: number | string, initialIndex?: number, scroller?: Scroller})
```

从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。

参数：

| 参数名       | 参数类型                                                     | 必填 | 参数描述                                                     |
| ------------ | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| space        | number &#124; string                                         | 否   | 子组件主轴方向的间隔。默认值：0。说明：设置为除 -1 外其它负数或百分比时，按默认值显示。space 参数值小于 List 分割线宽度时，子组件主轴方向的间隔取分割线宽度。 |
| initialIndex | number                                                       | 否   | 设置当前 List 初次加载时视口起始位置显示的 item 的索引值。默认值：0。说明：设置为除 -1 外其它负数或超过了当前 List 最后一个 item 的索引值时视为无效取值，无效取值按默认值显示。 |
| scroller     | [Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-container-scroll-0000001427902480-V2#ZH-CN_TOPIC_0000001523648790__scroller) | 否   | 可滚动组件的控制器。用于与可滚动组件进行绑定。说明：不允许和其它滚动类组件绑定同一个滚动控制对象。 |

##### List 属性

| 名称                 | 参数类型                                                     | 描述                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| listDirection        | [Axis](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-appendix-enums-0000001478061741-V2#ZH-CN_TOPIC_0000001574248789__axis) | 设置 List 组件排列方向。默认值：Axis.Vertical。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| divider              | { strokeWidth: Length;     color?: ResourceColor;     startMargin?: Length;     endMargin?: Length; } &#124; null | 设置 ListItem 分割线样式，默认无分割线。- strokeWidth：分割线的线宽。- color：分割线的颜色。- startMargin：分割线与列表侧边起始端的距离。- endMargin：分割线与列表侧边结束端的距离。从 API version 9 开始，该接口支持在ArkTS卡片中使用。endMargin + startMargin 不能超过列宽度。startMargin 和 endMargin 不支持设置百分比。List 的分割线画在主轴方向两个子组件之间，第一个子组件上方和最后一个子组件下方不会绘制分割线。多列模式下，ListItem 与 ListItem 之间的分割线起始边距从每一列的交叉轴方向起始边开始计算，其它情况从 List 交叉轴方向起始边开始计算。 |
| scrollBar            | [BarState](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-appendix-enums-0000001478061741-V2#ZH-CN_TOPIC_0000001574248789__barstate) | 设置滚动条状态。默认值：BarState.Oﬀ 从 API version 9 开始，该接口支持在 ArkTS卡片中使用。 |
| cachedCount          | number                                                       | 设置列表中 ListItem / ListItemGroup 的预加载数量，其中 ListItemGroup 将作为一个整体进行计算，ListItemGroup 中的所有 ListItem 会一次性全部加载出来。具体使用可参考[减少应用白块说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/ui-ts-performance-improvement-recommendation-0000001477981001-V2#ZH-CN_TOPIC_0000001523648418__%E5%87%8F%E5%B0%91%E5%BA%94%E7%94%A8%E6%BB%91%E5%8A%A8%E7%99%BD%E5%9D%97)。默认值：1。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。说明：单列模式下，会在 List 显示的 ListItem 前后各缓存 cachedCount 个 ListItem。多列模式下，会在 List 显示的 ListItem 前后各缓存 cachedCount 个 ListItem。 |
| editMode(deprecated) | boolean                                                      | 声明当前 List 组件是否处于可编辑模式。可参考[示例 3](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-container-list-0000001477981213-V2#section51541814101219) 实现删除选中的 list 项。从 API version9 开始废弃。默认值：false。 |
| edgeEﬀect            | [EdgeEﬀect](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-appendix-enums-0000001478061741-V2#ZH-CN_TOPIC_0000001574248789__edgeeffect) | 设置组件的滑动效果。默认值：EdgeEﬀect.Spring。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| chainAnimation       | boolean                                                      | 设置当前 List 是否启用链式联动动效，开启后列表滑动以及顶部和底部拖拽时会有链式联动的效果。链式联动效果：List 内的 listitem 间隔一定距离，在基本的滑动交互行为下，主动对象驱动从动对象进行联动，驱动效果遵循弹簧物理动效。默认值：false。- false：不启用链式联动。- true：启用链式联动。从 API version 9 开始，该接口支持在 ArkTS 卡片中 使用。 |
| multiSelectable8+    | boolean                                                      | 是否开启鼠标框选。默认值：false。- false：关闭框选。- true：开启框选。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| lanes9+              | number &#124; [LengthConstrain](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-types-0000001477981241-V2#ZH-CN_TOPIC_0000001573928889__lengthconstrain) | 以列模式为例（listDirection 为 Axis.Vertical）：lanes 用于决定 List 组件在交叉轴方向按几列布局。默认值：1。规则如下：- lanes 为指定的数量时，根据指定的数量与 List 组件的交叉轴尺寸除以列数作为列的宽度。\- lanes 设置了 {minLength，maxLength} 时， 根据 List 组件的宽度自适应决定 lanes 数量（即列数），保证缩放过程中 lane 的宽度符合 {minLength，maxLength} 的限制。其中，minLength 条件会被优先满足，即优先保证符合 ListItem 的交叉轴尺寸符合最小限制。\- lanes 设置了 {minLength，maxLength}，如果父组件交叉轴方向尺寸约束为无穷大时，固定按一列排列，列宽度按显示区域内最大的 ListItem 计算。\- ListItemGroup 在多列模式下也是独占一行，ListItemGroup 中的 ListItem 按照 List 组件的 lanes 属性设置值来布局。\- lanes 设置了 {minLength，maxLength} 时，计算列数会按照 ListItemGroup 的交叉轴尺寸计算。当 ListItemGroup 交叉轴尺寸与 List 交叉轴尺寸不一致时，ListItemGroup 中的列数与 List 中的列数可能不一样。该接口支持在 ArkTS 卡片中使用。 |
| alignListItem9+      | ListItemAlign                                                | List 交叉轴方向宽度大于 ListItem 交叉轴宽度 * lanes 时，ListItem 在 List 交叉轴方向的布局方式，默认为首部对齐。默认值：ListItemAlign.Start。该接口支持在 ArkTS 卡片中使用。 |
| sticky9+             | StickyStyle                                                  | 配合 ListItemGroup 组件使用，设置 ListItemGroup 中 header 和 footer 是否要吸顶或吸底。默认值：StickyStyle.None。该接口支持在 ArkTS 卡片中使用。说明：sticky 属性可设置为 StickyStyle.Header &#124; StickyStyle.Footer 以同时支持 header 吸顶和 footer 吸底。 |

##### List 事件

| 名称                                                         | 功能描述                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| onItemDelete(deprecated) (event: (index: number) => boolean) | 当 List 组件在编辑模式时，点击 ListItem 右边出现的删除按钮时触发。从 API version9 开始废弃。- index：被删除的列表项的索引值。 |
| onScroll(event: (scrollOﬀset: number, scrollState: ScrollState) => void) | 列表滑动时触发。- scrollOﬀset：滑动偏移量。- scrollState：当前滑动状态。使用控制器调用 ScrollEdge 和 ScrollToIndex 时不会触发，其余情况有滚动就会触发该事件。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| onScrollIndex(event: (start: number, end: number) => void)   | 列表滑动时触发。计算索引值时，ListItemGroup 作为一个整体占一个索引值，不计算 ListItemGroup 内部 ListItem 的索引值。- start：滑动起始位置索引值。- end：滑动结束位置索引值。触发该事件的条件：列表初始化时会触发一次，List 显示区域内第一个子组件的索引值或后一个子组件的索引值有变化时会触发。List 的边缘效果为弹簧效果时，在 List 滑动到边缘继续滑动和松手回弹过程不会触发 onScrollIndex 事件。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| onReachStart(event: () => void)                              | 列表到达起始位置时触发。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。说明：List 初始化时如果 initialIndex 为 0 会触发一次，List 滚动到起始位置时触发一次。List 边缘效果为弹簧效果时，滑动经过起始位置时触发一次，回弹回起始位置时再触发 一次。 |
| onReachEnd(event: () => void)                                | 列表到达末尾位置时触发。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。说明：List 边缘效果为弹簧效果时，滑动经过末尾位置时触发一次，回弹回末尾位置时再触发一次。 |
| onScrollFrameBegin9+ (event: (oﬀset: number, state: ScrollState) => { oﬀsetRemain }) | 列表开始滑动时触发，事件参数传入即将发生的滑动量，事件处理函数中可根据应用场景计算实际需要的滑动量并作为事件处理函数的返回值返回，列表将按照返回值的实际滑动量进行滑动。- oﬀset：即将发生的滑动量，单位 vp。- state：当前滑动状态。- oﬀsetRemain：实际滑动量，单位 vp。触发该事件的条件：手指拖动 List、List 惯性滑动时每帧开始时触发；List 超出边缘回弹、 使用滚动控制器的滚动不会触发。该接口支持在 ArkTS 卡片中使用。说明：当 listDirection 的值为 Axis.Vertical 时，返回垂直方向滑动量，当 listDirection 的值为 Axis.Horizontal 时，返回水平方向滑动量。 |
| onScrollStart9+(event: () => void)                           | 列表滑动开始时触发。手指拖动列表或列表的滚动条触发的滑动开始时，会触发该事件。使用 Scroller 滑动控制器触发的带动画的滑动，动画开始时会触发该事件。该接口支持在 ArkTS 卡片中使用。 |
| onScrollStop(event: () => void)                              | 列表滑动停止时触发。手拖动列表或列表的滚动条触发的滑动，手离开屏幕并且滑动停止时会触发该事件；使用 Scroller 滑动控制器触发的带动画的滑动，动画停止会触发该事件。从 API version 9 开始，该接口支持在 ArkTS 卡片中使用。 |
| onItemMove(event: (from: number, to: number) => boolean)     | 列表元素发生移动时触发。- from：移动前索引值。- to：移动后索引值。 |
| onItemDragStart(event: (event: ItemDragInfo, itemIndex: number) => ((() => any) &#124; void) | 开始拖拽列表元素时触发。- event：见 ItemDragInfo 对象说明。- itemIndex：被拖拽列表元素索引值。 |
| onItemDragEnter(event: (event: ItemDragInfo) => void)        | 拖拽进入列表元素范围内时触发。- event：见 ItemDragInfo 对象说明。 |
| onItemDragMove(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number) => void) | 拖拽在列表元素范围内移动时触发。- event：见 ItemDragInfo 对象说明。- itemIndex：拖拽起始位置。- insertIndex：拖拽插入位置。 |
| onItemDragLeave(event: (event: ItemDragInfo, itemIndex: number) => void) | 拖拽离开列表元素时触发。- event：见 ItemDragInfo 对象说明。- itemIndex：拖拽离开的列表元素索引值。 |
| onItemDrop(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) => void) | 绑定该事件的列表元素可作为拖拽释放目标，当在列表元素内停止拖拽时触发。- event：见 ItemDragInfo 对象说明。\- itemIndex：拖拽起始位置。- insertIndex：拖拽插入位置。\- isSuccess：是否成功释放。说明：跨 List 拖拽时，当拖拽释放的位置绑定了 onItemDrop 时会返回 true，否则为 false。List 内部拖拽时，isSuccess 为 onItemMove 事件的返回值。 |

##### List 普通垂直列表

```tsx
@Entry
@Component
struct Index {
  private arr: number[] = [0, 1, 2, 3, 5, 6, 7, 8]

  build() {
    Column() {
      List({ space: 10, initialIndex: 0 }) {
        ForEach(this.arr, (item: number) => {
          ListItem() {
            Text(item.toString())
              .width('100%')
              .height(100)
              .fontSize(24)
              .textAlign(TextAlign.Center)
              .borderRadius(10)
              .backgroundColor(0xFFFFFF)
          }
        }, (item: number) => item.toString())
      }
      .listDirection(Axis.Vertical) // 排列方向
      .divider({ strokeWidth: 2, color: 0xFF0000, startMargin: 20, endMargin: 20 }) // 每行之间的分界线
      .edgeEffect(EdgeEffect.None) // 滑动到边缘无效果
      .width('100%')
      .height('100%')
      .padding(10)
    }.width('100%').height('100%').backgroundColor(Color.Gray)
  }
}
```

##### List 微信用户中心布局

```tsx
interface UserListInterface {
  title: string,
  img: string
}

@Entry
@Component
struct Index {
  @State list: UserListInterface[] = [
    {
      title: "服务",
      img: "https://gitee.com/zch0304/images/raw/master/note/userlist/01.jpg"
    },
    {
      title: "收藏",
      img: "https://gitee.com/zch0304/images/raw/master/note/userlist/02.jpg"
    },
    {
      title: "朋友圈",
      img: "https://gitee.com/zch0304/images/raw/master/note/userlist/03.jpg"
    },
    {
      title: "视频号",
      img: "https://gitee.com/zch0304/images/raw/master/note/userlist/04.jpg"
    },
    {
      title: "卡包",
      img: "https://gitee.com/zch0304/images/raw/master/note/userlist/05.jpg"
    },
    {
      title: "表情",
      img: "https://gitee.com/zch0304/images/raw/master/note/userlist/06.jpg"
    },
    {
      title: "设置",
      img: "https://gitee.com/zch0304/images/raw/master/note/userlist/07.jpg"
    }
  ]

  build() {
    Column() {
      List({ space: 10, initialIndex: 0 }) {
        ListItem() {
          RelativeContainer() {
            Image("https://gitee.com/zch0304/images/raw/master/note/test_icon4.jpg")
              .id('avatar')
              .width(80)
              .height(80)
              .objectFit(ImageFit.Fill)
              .alignRules({
                left: { anchor: '__container__', align: HorizontalAlign.Start },
                top: { anchor: '__container__', align: VerticalAlign.Top }
              })
              .margin({ left: 20, top: 30 })

            Text("明年今日")
              .id('name')
              .fontSize(18)
              .alignRules({
                left: { anchor: 'avatar', align: HorizontalAlign.End },
                top: { anchor: 'avatar', align: VerticalAlign.Top }
              })
              .margin({ left: 10 })

            Text("微信号：zhich")
              .id('account')
              .fontSize(14)
              .alignRules({
                left: { anchor: 'avatar', align: HorizontalAlign.End },
                bottom: { anchor: 'avatar', align: VerticalAlign.Bottom }
              })
              .margin({ left: 10 })
          }.width('100%').height('200vp').backgroundColor(Color.White)
        }

        ListItem() {
          CustomItem({ model: this.list[0] })
        }

        ListItem() {
          Column() {
            ForEach(this.list, (item: UserListInterface, key) => {
              if (key > 0 && key < this.list.length - 1) {
                CustomItem({ model: item })
                Divider()
                  .strokeWidth(1)
                  .color("#eee")
                  .padding({ left: 20, right: 20 })
              }
            }, (item: UserListInterface) => item.img)
          }.backgroundColor(Color.White)
        }

        ListItem() {
          CustomItem({ model: this.list[this.list.length-1] })
        }

      }
      .edgeEffect(EdgeEffect.Spring)
      .width('100%')
      .height('100%')
    }.width('100%').height('100%').backgroundColor(0xeeeeee)
  }
}

@Component
struct CustomItem {
  model: UserListInterface = { title: "", img: "" }

  build() {
    Row() {
      Row() {
        Image(this.model.img)
          .width(28)
          .height(28)
          .objectFit(ImageFit.Cover)
        Text(`${this.model.title}`).fontSize(16)
      }

      Image("https://gitee.com/zch0304/images/raw/master/note/userlist/arrow_forward.jpg")
        .width(28)
        .height(28)
    }
    .width('100%')
    .backgroundColor(Color.White)
    .padding(10)
    .justifyContent(FlexAlign.SpaceBetween)
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1718296042527.jpg" style="zoom: 50%;" /> 

##### List 文章列表布局

```tsx
export class Article {
  key: string;
  title: string;
  img: string;
  author: string;
  date: string;

  constructor(key: string, title: string, img: string, author: string, date: string) {
    this.key = key;
    this.title = title;
    this.img = img;
    this.author = author;
    this.date = date;
  }
}
```

```tsx
import { Article } from '../model/Article'

@Entry
@Component
struct Index {
  @State articleList: Array<Article> = [
    new Article(
      '1',
      '新手攻略|开启关怀模式，与家人更亲近~',
      'https://gitee.com/zch0304/images/raw/master/note/article/01.png',
      '国家电网',
      '2024-12-2'
    ),
    new Article(
      '2',
      '反诈课堂|光伏骗局套路多听我给您细细说!',
      'https://gitee.com/zch0304/images/raw/master/note/article/02.png',
      '国家电网',
      '2024-4-2'
    ),
    new Article(
      '3',
      '新手攻略| 联合办、网上办一次办，这些地方的用户注',
      'https://gitee.com/zch0304/images/raw/master/note/article/03.png',
      '国家电网',
      '2024-1-12'
    ),
    new Article(
      '4',
      '新手攻略|轻轻一点，电费一键查询',
      'https://gitee.com/zch0304/images/raw/master/note/article/04.png',
      '国家电网',
      '2024-12-2'
    ),
    new Article(
      '5',
      '关注|局地降温超16C!寒潮天气来袭，注意防寒保暖!',
      'https://gitee.com/zch0304/images/raw/master/note/article/05.png',
      '国家电网',
      '2024-2-6'
    ),
  ]

  build() {
    Column() {
      List() {
        ForEach(this.articleList, (item: Article) => {
          ListItem() {
            Row() {
              Column() {
                Text(item.title).fontSize(16).fontWeight(FontWeight.Bold)
                Text(`${item.author}  ${item.date}`).fontSize(14)
              }
              .layoutWeight(1)
              .height('100%')
              .justifyContent(FlexAlign.SpaceBetween)
              .alignItems(HorizontalAlign.Start)

              Image(item.img).width(100).height(68).margin({ left: 5 }).borderRadius(10)
            }.height(80).alignItems(VerticalAlign.Center).padding({ bottom: 10, top: 10 })
          }
        }, (item: Article) => item.key)
      }
      .margin(10)
      .padding(10)
      .backgroundColor('#fff')
      .divider({ strokeWidth: 1, color: '#eee' })
    }.width('100%').height('100%').backgroundColor('#eee')
  }
}
```

<img src="https://gitee.com/zch0304/images/raw/master/note/1718376141035.jpg" style="zoom: 60%;" /> 

##### List 水平滑动列表

```tsx
export class ListItemModel {
  key: string;
  title: string;
  img: string

  constructor(key: string, title: string, img: string) {
    this.key = key;
    this.title = title;
    this.img = img;
  }
}
```

```tsx
import { ListItemModel } from '../model/ListItemModel'

@Entry
@Component
struct Index {
  @State list: Array<ListItemModel> = [
    new ListItemModel(
      '1',
      '关怀模式',
      'https://gitee.com/zch0304/images/raw/master/note/article/01.png'
    ),
    new ListItemModel(
      '2',
      '光伏骗局套',
      'https://gitee.com/zch0304/images/raw/master/note/article/02.png'
    ),
    new ListItemModel(
      '3',
      '网办小助手',
      'https://gitee.com/zch0304/images/raw/master/note/article/03.png'
    ),
    new ListItemModel(
      '4',
      '电费一键查询',
      'https://gitee.com/zch0304/images/raw/master/note/article/04.png'
    )
  ]

  build() {
    Column() {
      List({ space: 10 }) {
        ForEach(this.list, (item: ListItemModel) => {
          ListItem() {
            Column() {
              Image(item.img).width(100).height(68).margin({ top: 10 }).borderRadius(10)
              Text(item.title).fontSize(16).margin({ top: 10 })
            }
            .width(100)
            .height(110)
            .alignItems(HorizontalAlign.Center)
          }
        }, (item: ListItemModel) => item.key)
      }
      .width('100%')
      .height(120)
      .padding({ left: 10, right: 10 })
      .listDirection(Axis.Horizontal)
      .alignListItem(ListItemAlign.Center)
      .border({ width: 1, color: '#ccc' })
    }.width('100%').height('100%').backgroundColor('#eee')
  }
}
```

![](https://gitee.com/zch0304/images/raw/master/note/1718381624325.jpg) 