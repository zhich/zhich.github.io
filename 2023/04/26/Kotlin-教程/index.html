<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="uhuV0rnYMUWuzeZrPSHxh_QSZ6tM5AWsUD-fXyEVOOc">
  <meta name="baidu-site-verification" content="codeva-jBfPQBw271">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Times+New+Roman:300,300italic,400,400italic,700,700italic%7CConsolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-mac-osx.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhich.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":true,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"giscus","storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础类型Java 中存在 int, float, boolean 等基础类型，这些基础类型在 Kotlin 里将全部以对象的形式继续存在。有几点变化需要注意。 1234567&#x2F;&#x2F; Int 无法自动转换为 Double, 需要自己先做类型转换（as Double, toDouble(), 方式很多）var a: Int &#x3D; 2var b: Double &#x3D; a.toDouble()&#x2F;&#x2F;">
<meta property="og:type" content="blog">
<meta property="og:title" content="Kotlin 教程">
<meta property="og:url" content="https://zhich.github.io/2023/04/26/Kotlin-%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="明年今日">
<meta property="og:description" content="基础类型Java 中存在 int, float, boolean 等基础类型，这些基础类型在 Kotlin 里将全部以对象的形式继续存在。有几点变化需要注意。 1234567&#x2F;&#x2F; Int 无法自动转换为 Double, 需要自己先做类型转换（as Double, toDouble(), 方式很多）var a: Int &#x3D; 2var b: Double &#x3D; a.toDouble()&#x2F;&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-26T13:47:00.000Z">
<meta property="article:modified_time" content="2024-06-03T14:53:51.435Z">
<meta property="article:author" content="明年今日">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Kotlin">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhich.github.io/2023/04/26/Kotlin-%E6%95%99%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhich.github.io/2023/04/26/Kotlin-%E6%95%99%E7%A8%8B/","path":"2023/04/26/Kotlin-教程/","title":"Kotlin 教程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Kotlin 教程 | 明年今日</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">明年今日</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-globe fa-fw fa-fw"></i>links</a></li><li class="menu-item menu-item-happy"><a href="/happy/" rel="section"><i class="fa fa-th fa-fw"></i>happy</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">基础类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">2.</span> <span class="nav-text">变量声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="nav-number">3.</span> <span class="nav-text">类型声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B"><span class="nav-number">4.</span> <span class="nav-text">类型检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Any-%E5%92%8C-Unit"><span class="nav-number">5.</span> <span class="nav-text">Any 和 Unit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">6.</span> <span class="nav-text">可见性修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.</span> <span class="nav-text">逻辑语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if-else-%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.1.</span> <span class="nav-text">if-else 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#when-%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.2.</span> <span class="nav-text">when 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">7.3.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE"><span class="nav-number">7.4.</span> <span class="nav-text">标签</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">8.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF"><span class="nav-number">9.</span> <span class="nav-text">字符串模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0-%E9%A1%B6%E7%BA%A7%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.</span> <span class="nav-text">全局函数&#x2F;顶级函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.</span> <span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0"><span class="nav-number">10.3.</span> <span class="nav-text">局部函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">10.4.</span> <span class="nav-text">函数参数默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7"><span class="nav-number">10.5.</span> <span class="nav-text">扩展函数和扩展属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#infix-%E5%87%BD%E6%95%B0"><span class="nav-number">10.6.</span> <span class="nav-text">infix 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">10.7.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">10.8.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">10.9.</span> <span class="nav-text">Lambda 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">10.10.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">10.11.</span> <span class="nav-text">标准高阶函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">11.</span> <span class="nav-text">实化类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">12.</span> <span class="nav-text">类与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">12.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">12.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E4%B8%8E%E4%BC%B4%E9%9A%8F%E5%AF%B9%E8%B1%A1"><span class="nav-number">12.3.</span> <span class="nav-text">单例与伴随对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">12.4.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">12.5.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-number">13.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3-%E6%9E%9A%E4%B8%BE-%E6%B3%A8%E8%A7%A3"><span class="nav-number">14.</span> <span class="nav-text">声明抽象类&#x2F;接口&#x2F;枚举&#x2F;注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="nav-number">15.</span> <span class="nav-text">受检异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Class-%E5%AF%B9%E8%B1%A1"><span class="nav-number">16.</span> <span class="nav-text">获取 Class 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setter-getter"><span class="nav-number">17.</span> <span class="nav-text">setter&#x2F;getter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JvmXxx-%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number">18.</span> <span class="nav-text">JvmXxx 相关注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JvmField"><span class="nav-number">18.1.</span> <span class="nav-text">JvmField</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JvmName"><span class="nav-number">18.2.</span> <span class="nav-text">JvmName</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JvmStatic"><span class="nav-number">18.3.</span> <span class="nav-text">JvmStatic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JvmOverloads"><span class="nav-number">18.4.</span> <span class="nav-text">JvmOverloads</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E5%A4%84%E7%9B%AE%E6%A0%87"><span class="nav-number">19.</span> <span class="nav-text">注解使用处目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Elvis-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">20.</span> <span class="nav-text">Elvis 操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%AE%89%E5%85%A8"><span class="nav-number">21.</span> <span class="nav-text">空指针安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lateinit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">22.</span> <span class="nav-text">lateinit 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data-class"><span class="nav-number">23.</span> <span class="nav-text">data class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E7%AD%89%E6%80%A7"><span class="nav-number">24.</span> <span class="nav-text">相等性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#operator"><span class="nav-number">25.</span> <span class="nav-text">operator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98"><span class="nav-number">26.</span> <span class="nav-text">委托</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%A7%94%E6%89%98"><span class="nav-number">26.1.</span> <span class="nav-text">类委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98"><span class="nav-number">26.2.</span> <span class="nav-text">属性委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">26.3.</span> <span class="nav-text">属性委托的另一种实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E4%B8%AA%E5%A7%94%E6%89%98"><span class="nav-number">26.4.</span> <span class="nav-text">标准库中提供的几个委托</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E5%87%BD%E6%95%B0%E5%BC%8F-API-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">27.</span> <span class="nav-text">集合中函数式 API 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%9B%E9%80%89%E8%BF%87%E6%BB%A4%E7%B1%BB"><span class="nav-number">27.1.</span> <span class="nav-text">筛选过滤类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#slice-%E7%B3%BB%E5%88%97"><span class="nav-number">27.1.1.</span> <span class="nav-text">slice 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#filter-%E7%B3%BB%E5%88%97"><span class="nav-number">27.1.2.</span> <span class="nav-text">filter 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#drop-%E7%B3%BB%E5%88%97"><span class="nav-number">27.1.3.</span> <span class="nav-text">drop 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#take-%E7%B3%BB%E5%88%97"><span class="nav-number">27.1.4.</span> <span class="nav-text">take 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#distinct-%E7%B3%BB%E5%88%97"><span class="nav-number">27.1.5.</span> <span class="nav-text">distinct 系列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E9%9B%86%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">27.2.</span> <span class="nav-text">并集类操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#any%E3%80%81all%E3%80%81count%E3%80%81none-%E7%B3%BB%E5%88%97"><span class="nav-number">27.2.1.</span> <span class="nav-text">any、all、count、none 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fold-%E7%B3%BB%E5%88%97"><span class="nav-number">27.2.2.</span> <span class="nav-text">fold 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#forEach-%E7%B3%BB%E5%88%97"><span class="nav-number">27.2.3.</span> <span class="nav-text">forEach 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#max%E3%80%81min-%E7%B3%BB%E5%88%97"><span class="nav-number">27.2.4.</span> <span class="nav-text">max、min 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reduce-%E7%B3%BB%E5%88%97"><span class="nav-number">27.2.5.</span> <span class="nav-text">reduce 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sum-%E7%B3%BB%E5%88%97"><span class="nav-number">27.2.6.</span> <span class="nav-text">sum 系列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">27.3.</span> <span class="nav-text">映射类操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#flatMap-%E7%B3%BB%E5%88%97"><span class="nav-number">27.3.1.</span> <span class="nav-text">flatMap 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#group-%E7%B3%BB%E5%88%97"><span class="nav-number">27.3.2.</span> <span class="nav-text">group 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map-%E7%B3%BB%E5%88%97"><span class="nav-number">27.3.3.</span> <span class="nav-text">map 系列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">27.4.</span> <span class="nav-text">元素类操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#element-%E7%B3%BB%E5%88%97"><span class="nav-number">27.4.1.</span> <span class="nav-text">element 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#first%E3%80%81last-%E7%B3%BB%E5%88%97"><span class="nav-number">27.4.2.</span> <span class="nav-text">first、last 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#find-%E7%B3%BB%E5%88%97"><span class="nav-number">27.4.3.</span> <span class="nav-text">find 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#single-%E7%B3%BB%E5%88%97"><span class="nav-number">27.4.4.</span> <span class="nav-text">single 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#component-%E7%B3%BB%E5%88%97"><span class="nav-number">27.4.5.</span> <span class="nav-text">component 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#indexOf-%E7%B3%BB%E5%88%97"><span class="nav-number">27.4.6.</span> <span class="nav-text">indexOf 系列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">27.5.</span> <span class="nav-text">排序类操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#reverse-%E7%B3%BB%E5%88%97"><span class="nav-number">27.5.1.</span> <span class="nav-text">reverse 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sort-%E7%B3%BB%E5%88%97"><span class="nav-number">27.5.2.</span> <span class="nav-text">sort 系列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">27.6.</span> <span class="nav-text">生成类操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#partition-%E7%B3%BB%E5%88%97"><span class="nav-number">27.6.1.</span> <span class="nav-text">partition 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#plus-%E7%B3%BB%E5%88%97"><span class="nav-number">27.6.2.</span> <span class="nav-text">plus 系列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#zip-%E7%B3%BB%E5%88%97"><span class="nav-number">27.6.3.</span> <span class="nav-text">zip 系列</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="明年今日"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">明年今日</p>
  <div class="site-description" itemprop="description">终身学习者。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poaWNo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhich"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnpoaWNoMTEyMTM0QGdtYWlsLmNvbQ==" title="E-Mail → mailto:zhich112134@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhich.github.io/2023/04/26/Kotlin-%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="明年今日">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="明年今日">
      <meta itemprop="description" content="终身学习者。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Kotlin 教程 | 明年今日">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kotlin 教程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-26 21:47:00" itemprop="dateCreated datePublished" datetime="2023-04-26T21:47:00+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-03 22:53:51" itemprop="dateModified" datetime="2024-06-03T22:53:51+08:00">2024-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><meta name="referrer" content="no-referrer" />





<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>Java 中存在 int, float, boolean 等基础类型，这些基础类型在 Kotlin 里将全部以对象的形式继续存在。有几点变化需要注意。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Int 无法自动转换为 Double, 需要自己先做类型转换（as Double, toDouble(), 方式很多）</span></span><br><span class="line"><span class="keyword">var</span> a: <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="built_in">Double</span> = a.toDouble()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Char 不能直接等值于其对应的 ASCII 码值，需要类型转换</span></span><br><span class="line"><span class="keyword">var</span> c: <span class="built_in">Char</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">var</span> x: <span class="built_in">Int</span> = c.toInt()</span><br></pre></td></tr></table></figure>

<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Kotlin 中使用 var 定义可读可写变量，使用 val 定义只读变量（相当于 Java 当中的 final）。定义变量时，如果满足类型推断，类型可以省略。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&quot;100&quot;</span> <span class="comment">// 类型为 String</span></span><br><span class="line"><span class="keyword">var</span> name: String = <span class="string">&quot;张三&quot;</span> <span class="comment">// 类型为 String</span></span><br><span class="line"><span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p>在 Kotlin 语言中，“:” 被广泛用于变量类型的定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变量类型</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> zhangSan: User</span><br><span class="line">    <span class="keyword">var</span> liSi: User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数参数和返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">Int</span>)</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">return</span> User(<span class="number">100</span>, <span class="string">&quot;dd&quot;</span>, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“:”还被用于声明类继承或接口实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 User 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VipUser</span> : <span class="type">User</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DB</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addUser</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 DB 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoomDB</span> : <span class="type">DB</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p>Java 中使用 instanceof 来判断某变量是否为某类型，而 Kotlin 中使用 is 来进行类型检测。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is 判断属于某类型</span></span><br><span class="line"><span class="comment"> * !is 判断不属于某类型</span></span><br><span class="line"><span class="comment"> * as 类型强转，失败时抛出类型强转失败异常</span></span><br><span class="line"><span class="comment"> * as? 类型强转，但失败时不会抛出异常而是返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (myObject <span class="keyword">is</span> User) &#123;</span><br><span class="line">    <span class="comment">// 只要进来了，就代表 myObject 是 User 类型了，不需要强转就可以直接使用 User 的属性</span></span><br><span class="line">    myObject.id = <span class="number">101</span></span><br><span class="line">    myObject.name = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Any-和-Unit"><a href="#Any-和-Unit" class="headerlink" title="Any 和 Unit"></a>Any 和 Unit</h3><ul>
<li><strong>Any</strong>: Kotlin 的顶层父类是 Any, 对应 Java 中的 Object, 但是比 Object 少了 wait()&#x2F;notify() 等函数。</li>
<li><strong>Unit</strong>: Kotlin 中的 Unit 对应 Java 中的 void。</li>
</ul>
<h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><ul>
<li>默认的可见性修饰符是 <code>public</code>。</li>
<li>新增的可见性修饰符 <code>internal</code> 表示仅当前模块（AS 中的 module）可见，其它模块不能访问。</li>
</ul>
<h3 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h3><h4 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h4><p>Kotlin 中的 if-else 基本和 Java 一致，但还是有一些特殊的地方。比如它可以作为一个逻辑表达式使用，逻辑表达式还可以以代码块的形式出现，代码块最后的表达式作为该块的返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑表达式的使用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMax</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="keyword">if</span> (x &gt; y) x <span class="keyword">else</span> y</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码块形式的逻辑表达式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMax2</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        println(<span class="string">&quot;Max num is x.&quot;</span>)</span><br><span class="line">        x <span class="comment">// 返回最后一行，即 x 的值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Max num is y.&quot;</span>)</span><br><span class="line">        y <span class="comment">// 返回最后一行，即 y 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="when-语句"><a href="#when-语句" class="headerlink" title="when 语句"></a>when 语句</h4><p>Kotlin 中的 when 语句取代了 Java 中的 switch-case 语句，功能上要强大许多，可以有多种形式的条件表达。与 if-else 一样，Kotlin 中的 when 也可以作为逻辑表达式使用，也有返回值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// when 有判断参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">whenDemo</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (obj) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; println(<span class="string">&quot;是数字 1&quot;</span>)</span><br><span class="line">        -<span class="number">1</span>, <span class="number">0</span> -&gt; println(<span class="string">&quot;是数字 -1 或 0&quot;</span>)</span><br><span class="line">        <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; println(<span class="string">&quot;是不大于 10 的正整数&quot;</span>)</span><br><span class="line">        <span class="string">&quot;abc&quot;</span> -&gt; println(<span class="string">&quot;是字符串 abc&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> User -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;是 User 对象&quot;</span>)</span><br><span class="line">            println(obj.name) <span class="comment">// 直接可以使用 User 的属性了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;其它操作&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// when 没有判断参数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">whenDemo2</span><span class="params">(position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> columns = <span class="number">10</span></span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        position % columns == <span class="number">0</span> -&gt; &#123; <span class="comment">// position 位于第一列</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        (position + <span class="number">1</span>) % columns == <span class="number">0</span> -&gt; &#123; <span class="comment">// position 位于最后一列</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// when 有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">whenDemo3</span><span class="params">(score: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">when</span> (score) &#123;</span><br><span class="line">        <span class="keyword">in</span> <span class="number">90.</span><span class="number">.100</span> -&gt; <span class="string">&quot;优秀&quot;</span></span><br><span class="line">        <span class="keyword">in</span> <span class="number">80.</span><span class="number">.89</span> -&gt; <span class="string">&quot;良好&quot;</span></span><br><span class="line">        <span class="keyword">in</span> <span class="number">60.</span><span class="number">.79</span> -&gt; <span class="string">&quot;及格&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;不及格&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;你的成绩<span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准函数 repeat()：</span></span><br><span class="line">repeat(<span class="number">100</span>) &#123; <span class="comment">// 执行 100 次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .. 包括右边界 [0,99]</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.99</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// until 不包括右边界 [0,99]</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">100</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>while 语句、continue 语句和 break 语句等逻辑都与 Java 基本一致，这里不再赘述。</p>
</blockquote>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>Kotlin 中可以对任意表达式进行标签标记，标签的格式为标识符后跟 @ 符号，例如 abc@、fooBar@ 都是有效的标签。这些标签，可以搭配 return、break、continue 等跳转行为来使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">labelTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="symbol">la@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;outer index <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;inner index <span class="variable">$j</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span><span class="symbol">@la</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用 <code>arrayOf</code> 创建数组，基本数据类型使用对应的 <code>intArrayOf</code> 等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr1 = arrayOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> arr2 = intArrayOf()</span><br><span class="line"><span class="keyword">var</span> arr3 = floatArrayOf()</span><br></pre></td></tr></table></figure>

<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 中字符串模板</span></span><br><span class="line">String name = <span class="string">&quot;ZhangSan&quot;</span>;</span><br><span class="line">int age = <span class="number">30</span>;</span><br><span class="line">String introduction = String.format(<span class="string">&quot;我是s%，今年%d岁了&quot;</span>, name, age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin 中字符串模板</span></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;ZhangSan&quot;</span></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">30</span></span><br><span class="line"><span class="keyword">val</span> introduction = <span class="string">&quot;我是<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁了&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Kotlin 中的函数通过关键字 fun 定义的，具体的参数和返回值定义结构如下。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myFun</span><span class="params">(para1: <span class="type">Int</span>, para2: <span class="type">String</span>)</span></span>: String &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin 中的函数可以是全局函数，成员函数或者局部函数，甚至还可以作为某个对象的扩展函数临时添加。</p>
<h4 id="全局函数-顶级函数"><a href="#全局函数-顶级函数" class="headerlink" title="全局函数&#x2F;顶级函数"></a>全局函数&#x2F;顶级函数</h4><p>全局函数（顶级函数）是文件级别的，以包为作用域。</p>
<p>例如 com.zch.kotlin.biz1 包中的 Common.kt 文件中有以下方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在当前包的其它文件中就不能有相同的方法 sayHello，否则会报错。</p>
<p>如果 com.zch.kotlin.biz2 包中的某文件中也有以下方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在其它文件中同时调用两者就需要加上相应的包来访问。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.zch.kotlin.biz1.sayHello</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">    com.zch.kotlin.biz2.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>成员函数是在类或对象内部定义的函数。</p>
<h4 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h4><p>Kotlin 支持局部函数，即一个函数在另一个函数内部：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> country = <span class="string">&quot;中国&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数中的函数，叫“局部函数”</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getProvince</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">$&#123;country&#125;</span>广东省&quot;</span> <span class="comment">// 局部函数可以访问外部函数的局部变量。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;ZhangSan&quot;</span></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">30</span></span><br><span class="line">    <span class="keyword">val</span> userInfo = <span class="string">&quot;我是<span class="subst">$&#123;name&#125;</span>，今年<span class="subst">$&#123;age&#125;</span>岁了，我来自<span class="subst">$&#123;getProvince()&#125;</span>。&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是频繁调用的函数，不建议声明为局部函数，因为每次调用时，就会产生一个函数对象。</p>
</blockquote>
<h4 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h4><p>函数中的某个参数可以用 “&#x3D;” 号指定其默认值，调用函数方法时可不传这个参数，但其它参数需要用 “&#x3D;” 号指定。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span> = <span class="number">10</span>, c: <span class="type">Int</span>)</span></span> = a + b + c <span class="comment">// 原本直接 return 的函数可以用 = 符号简化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sum = calculate(<span class="number">5</span>, c = <span class="number">20</span>) <span class="comment">// sum = 35</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展函数和扩展属性"><a href="#扩展函数和扩展属性" class="headerlink" title="扩展函数和扩展属性"></a>扩展函数和扩展属性</h4><p>Kotlin 支持在<strong>包范围内</strong>对已存在的类进行函数和属性扩展。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 Activity 扩展一个 log 函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Activity.<span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;Activity---<span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 Context 扩展一个 log 函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;Context---<span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 调用 Activity.log</span></span><br><span class="line">(<span class="keyword">this</span> <span class="keyword">as</span> Context).log(<span class="string">&quot;hello2&quot;</span>) <span class="comment">// 调用 Context.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 ViewGroup 扩展一个 firstChild 属性</span></span><br><span class="line"><span class="keyword">val</span> ViewGroup.firstChild: View <span class="keyword">get</span>() = getChildAt(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">contentLayout.firstChild <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：1、扩展需要在包级范围内进行，如果写在 class 内是无效的。2、已经存在的方法或属性，是无法被扩展的，依旧会调用已有的方法。3、扩展函数是静态解析的，在编译时就确定了调用函数（没有多态）。</p>
</blockquote>
<h4 id="infix-函数"><a href="#infix-函数" class="headerlink" title="infix 函数"></a>infix 函数</h4><p>标有 <code>infix</code> 关键字的函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。中缀函数必须满足以下要求：</p>
<ul>
<li>它们必须是成员函数或扩展函数；</li>
<li>它们必须只有一个参数；</li>
<li>其参数不得接受可变数量的参数且不能有默认值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">shl</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用中缀表示法调用该函数</span></span><br><span class="line"><span class="number">1</span> shl <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于这样</span></span><br><span class="line"><span class="number">1.</span>shl(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中缀函数调用的优先级低于算术操作符、类型转换以及 rangeTo 操作符。 以下表达式是等价的：</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> shl <span class="number">2</span> + <span class="number">3</span> 等价于 <span class="number">1</span> shl (<span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line"><span class="number">0</span> until n * <span class="number">2</span> 等价于 <span class="number">0</span> until (n * <span class="number">2</span>)</span><br><span class="line">xs union ys <span class="keyword">as</span> Set&lt;*&gt; 等价于 xs union (ys <span class="keyword">as</span> Set&lt;*&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一方面，中缀函数调用的优先级高于布尔操作符 &amp;&amp; 与 ||、is- 与 in- 检测以及其他一些操作符。这些表达式也是等价的：</span></span><br><span class="line"></span><br><span class="line">a &amp;&amp; b xor c 等价于 a &amp;&amp; (b xor c)</span><br><span class="line">a xor b <span class="keyword">in</span> c 等价于 (a xor b) <span class="keyword">in</span> c</span><br></pre></td></tr></table></figure>

<p>中缀函数总是要求指定接收者与参数。当使用中缀表示法在当前接收者上调用方法时，需要显式使用 <code>this</code>；不能像常规方法调用那样省略。这是确保非模糊解析所必需的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStringCollection</span> &#123;</span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span> add <span class="string">&quot;abc&quot;</span>   <span class="comment">// 正确</span></span><br><span class="line">        add(<span class="string">&quot;abc&quot;</span>)       <span class="comment">// 正确</span></span><br><span class="line">        add <span class="string">&quot;abc&quot;</span>      <span class="comment">// 错误：必须指定接收者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><ul>
<li>内联函数配合「函数类型」，可以减少「函数类型」生成的对象  。</li>
<li>使⽤ <code>inline</code> 关键字声明的函数是「内联函数」，在「编译时」会将「内联函数」中的函数体直接插⼊到调⽤处。  所以在写内联函数的时候需要注意，尽量将内联函数中的代码行数减少。</li>
</ul>
<p><code>noinline</code> 可以禁止部分函数参数参与内联编译：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(inlined: () -&gt; <span class="type">Unit</span>, <span class="keyword">noinline</span> notInlined:() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul>
<li>匿名函数的特点是可以明确指定其返回值类型。</li>
<li>它和常规函数的定义几乎相似。他们的区别在于，匿名函数没有函数名。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(x : <span class="type">Int</span> , y : <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = x + y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">(x : <span class="type">Int</span> , y : <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = x + y</span><br></pre></td></tr></table></figure>

<h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><p><code>Lambda</code> 表达式的本质是 <code>匿名函数</code>，因为在其底层实现中还是通过匿名函数来实现的。但是我们在用的时候不必关心其底层实现。不过 Lambda 的出现确实是减少了代码量的编写，同时也使代码变得更加简洁明了。</p>
<p><strong>1、Lambda 的特点：</strong></p>
<ul>
<li>Lambda 表达式总是被大括号括着。</li>
<li>其参数（如果存在）在符号 “-&gt;” 之前声明（参数类型可以省略）。</li>
<li>函数体（如果存在）在符号 “-&gt;” 后面。</li>
</ul>
<p><strong>2、Lambda 语法：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、无参数的情况：</span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = &#123; 操作的代码 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">myFun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;无参数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda 代码</span></span><br><span class="line"><span class="keyword">val</span> myFun1 = &#123; println(<span class="string">&quot;无参数&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFun1() <span class="comment">// 调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="number">2</span>、有参数的情况：</span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 : (参数的类型，参数类型，...) -&gt; 返回值类型 = &#123;参数<span class="number">1</span>，参数<span class="number">2</span>，... -&gt; 操作参数的代码 &#125;</span><br><span class="line">可等价于</span><br><span class="line"><span class="comment">// 此种写法：即表达式的返回值类型会根据操作的代码自推导出来。</span></span><br><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> 变量名 = &#123; 参数<span class="number">1</span> ： 类型，参数<span class="number">2</span> : 类型, ... -&gt; 操作参数的代码 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myFun2</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line"><span class="keyword">val</span> myFun2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; a, b -&gt; a + b &#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">val</span> myFun2 = &#123; a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt; a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFun2(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="number">3</span>、lambda 表达式作为函数中的参数：</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(a : <span class="type">Int</span>, 参数名 : (参数1 ： 类型，参数2 : 类型, ... ) -&gt; 表达式返回类型)</span></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myFun3</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myFun33</span><span class="params">(a: <span class="type">Int</span>, b: (<span class="type">num1</span>: <span class="type">Int</span>, <span class="type">num2</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b.invoke(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFun33(<span class="number">10</span>, &#123; num1: <span class="built_in">Int</span>, num2: <span class="built_in">Int</span> -&gt; num1 + num2 &#125;) <span class="comment">// 调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>invoke() 函数：表示为通过函数变量调用自身，因为上面例子中的变量 b 是一个匿名函数。</p>
</blockquote>
<p><strong>3、it</strong></p>
<p>当一个高阶函数中 Lambda 表达式的参数只有一个的时候可以使用 it 来使用此参数。it 可表示为单个参数的隐式名称，是 Kotlin 语言约定的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">arr.forEach &#123;</span><br><span class="line">    sum += it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、下划线（_）</strong></p>
<p>在使用 Lambda 表达式的时候，可以用下划线 （_） 表示未使用的参数，表示不处理这个参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;key1&quot;</span> to <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span> to <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;key3&quot;</span> to <span class="string">&quot;value3&quot;</span>)</span><br><span class="line"><span class="comment">// 不需要 key 的时候</span></span><br><span class="line">map.forEach &#123; _, value -&gt;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、带接收者的函数字面值</strong></p>
<p>在 Kotlin 中，提供了指定的接受者对象调用 Lambda 表达式的功能。在函数字面值的函数体中，可以调用该接收者对象上的方法而无需任何额外的限定符。它类似于扩展函数，它允许在函数体内访问接收者对象的成员。</p>
<p><strong>5.1、匿名函数作为接收者类型</strong></p>
<p>匿名函数语法允许你直接指定函数字面值的接收者类型，如果你需要使用带接收者的函数类型声明一个变量，并在之后使用它，这将非常有用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> add = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">( other : <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = <span class="keyword">this</span> + other</span><br><span class="line">println(<span class="number">2.</span>add(<span class="number">3</span>)) <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure>

<p><strong>5.2、Lambda 表达式作为接收者类型</strong></p>
<p>要用 Lambda 表达式作为接收者类型的前提是<strong>接收者类型可以从上下文中推断出来</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HTML</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">body</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myFun5</span><span class="params">(<span class="keyword">init</span>: <span class="type">HTML</span>.() -&gt; <span class="type">Unit</span>)</span></span>: HTML &#123;</span><br><span class="line">    <span class="keyword">val</span> html = HTML() <span class="comment">// 创建接收者对象</span></span><br><span class="line">    html.<span class="keyword">init</span>()       <span class="comment">// 将该接收者对象传给该 lambda</span></span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test111</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFun5 &#123; <span class="comment">// 带接收者的 lambda 由此开始</span></span><br><span class="line">        body() <span class="comment">// 调用该接收者对象的一个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、闭包</strong></p>
<p>所谓闭包，即是函数中包含函数，这里的函数我们可以包含（Lambda 表达式，匿名函数，局部函数，对象表达式）。我们熟知，函数式编程是现在和未来良好的一种编程趋势，故而 Kotlin 也有这一个特性。Java 是不支持闭包的。</p>
<p><strong>6.1、携带状态</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让函数返回一个函数，并携带状态值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myFun4</span><span class="params">(b: <span class="type">Int</span>)</span></span>: () -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        a++</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> t = myFun4(<span class="number">3</span>)</span><br><span class="line">    println(t()) <span class="comment">// 输出 7</span></span><br><span class="line">    println(t()) <span class="comment">// 输出 8</span></span><br><span class="line">    println(t()) <span class="comment">// 输出 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.2、引用外部变量，并改变外部变量的值</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum : <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> arr = arrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">arr.filter &#123; it &lt; <span class="number">7</span>  &#125;.forEach &#123; sum += it &#125;</span><br><span class="line"></span><br><span class="line">println(sum) <span class="comment">// 输出 9</span></span><br></pre></td></tr></table></figure>

<p><strong>7、Lambda 表达式简写</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果函数的最后⼀个参数是 lambda, 那么 lambda 表达式可以放在圆括号之外：</span></span><br><span class="line">lessons.forEach()&#123; lesson : Lesson -&gt;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你的函数传⼊参数只有⼀个 lambda 的话，那么⼩括号可以省略的：</span></span><br><span class="line">lessons.forEach &#123; lesson : Lesson -&gt;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 lambda 表达式只有⼀个参数，那么可以省略，通过隐式的 it 来访问：</span></span><br><span class="line">lessons.forEach &#123; <span class="comment">// it</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>在 <code>Kotlin</code> 中，高阶函数即指：将函数用作一个函数的参数或者返回值的函数。</p>
<p><strong>将函数用作函数参数的情况</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sumBy 函数的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">sumBy</span><span class="params">(selector: (<span class="type">Char</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        sum += selector(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="keyword">val</span> sum = str.sumBy &#123; it.toInt() &#125;</span><br><span class="line">    println(sum) <span class="comment">// 输出 294。因为字符 a 对应的值为 97，b 对应 98，c 对应 99。故而该值即为 97 + 98 + 99 = 294</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将函数用作一个函数的返回值</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lock</span><span class="params">(lock: <span class="type">Lock</span>, body: () -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toBeSynchronized</span><span class="params">()</span></span> = sharedResource.operation()</span><br><span class="line"><span class="keyword">val</span> result = lock(lock, ::toBeSynchronized) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的写法也可以写作：</span></span><br><span class="line"><span class="keyword">val</span> result = lock(lock, &#123;sharedResource.operation()&#125; )</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">val</span> result = lock(lock) &#123;</span><br><span class="line">    sharedResource.operation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>::toBeSynchronized 即为对函数 toBeSynchronized() 的引用。</p>
</blockquote>
<p><strong>自定义高阶函数</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义高阶函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculation</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, result: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result(num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = calculation(<span class="number">1</span>, <span class="number">2</span>) &#123; num1, num2 -&gt;</span><br><span class="line">        num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> result2 = calculation(<span class="number">10</span>, <span class="number">20</span>) &#123; num1, num2 -&gt;</span><br><span class="line">        num1 * num2</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;result1 = <span class="variable">$result1</span>&quot;</span>) <span class="comment">// 输出：3</span></span><br><span class="line">    println(<span class="string">&quot;result2 = <span class="variable">$result2</span>&quot;</span>) <span class="comment">// 输出：200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开发中常用的一个例子</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParamView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span>) : LinearLayout(context, attrs, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> onParamValueClickListener: (() -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span> <span class="comment">// 定义一个点击事件，给外部处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        tvParamValue?.setOnClickListener &#123;</span><br><span class="line">            onParamValueClickListener?.invoke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部 ParamView 控件处理点击事件</span></span><br><span class="line">paramView?.onParamValueClickListener = &#123;</span><br><span class="line">    <span class="comment">// 处理业务逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标准高阶函数"><a href="#标准高阶函数" class="headerlink" title="标准高阶函数"></a>标准高阶函数</h4><p>Standard.kt 文件中提供了一系列标准的高阶函数。</p>
<p><strong>函数特点汇总</strong></p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">接收者（this）</th>
<th align="left">传参（it）</th>
<th align="left">返回值（result）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">run()</td>
<td align="left">当前类</td>
<td align="left">编译错误</td>
<td align="left">作用域中的最后一个对象</td>
</tr>
<tr>
<td align="left">T.run()</td>
<td align="left">类T</td>
<td align="left">编译错误</td>
<td align="left">作用域中的最后一个对象</td>
</tr>
<tr>
<td align="left">with()</td>
<td align="left">类T</td>
<td align="left">编译错误</td>
<td align="left">作用域中的最后一个对象</td>
</tr>
<tr>
<td align="left">T.let()</td>
<td align="left">当前类</td>
<td align="left">类T</td>
<td align="left">作用域中的最后一个对象</td>
</tr>
<tr>
<td align="left">T.also()</td>
<td align="left">当前类</td>
<td align="left">类T</td>
<td align="left">类T</td>
</tr>
<tr>
<td align="left">T.apply()</td>
<td align="left">类T</td>
<td align="left">编译错误</td>
<td align="left">类T</td>
</tr>
</tbody></table>
<p>实际应用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStandard</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MyStandard&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run()</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">runDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&quot;AA&quot;</span></span><br><span class="line">        run &#123;</span><br><span class="line">            <span class="keyword">val</span> name = <span class="string">&quot;BB&quot;</span></span><br><span class="line">            Log.e(TAG, name) <span class="comment">// BB</span></span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, name) <span class="comment">// AA</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T.run()</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">runDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="string">&quot;ABCDEF&quot;</span>.run &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;字符串的长度为 <span class="variable">$length</span>&quot;</span>) <span class="comment">// 字符串的长度为 6</span></span><br><span class="line">            substring(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, result) <span class="comment">// CDEF</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with()</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> result = with(<span class="string">&quot;ABCDEF&quot;</span>) &#123;</span><br><span class="line">            substring(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, result) <span class="comment">// CDEF</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T.let()</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">letDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="string">&quot;ABCDEF&quot;</span>.let &#123;</span><br><span class="line">            it.substring(<span class="number">2</span>) <span class="comment">// it 代表 &quot;ABCDEF&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, result) <span class="comment">// CDEF</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T.also()</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">alsoDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="string">&quot;ABCDEF&quot;</span>.also &#123;</span><br><span class="line">            it.substring(<span class="number">2</span>) <span class="comment">// it 代表 &quot;ABCDEF&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, result) <span class="comment">// ABCDEF</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T.apply()</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">applyDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="string">&quot;ABCDEF&quot;</span>.apply &#123;</span><br><span class="line">            <span class="keyword">this</span>.substring(<span class="number">2</span>) <span class="comment">// this 代表 &quot;ABCDEF&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, result) <span class="comment">// ABCDEF</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，T.run()、T.let()、T.also() 和 T.apply() 四个用的比较多，使用时可以通过简单的规则作出⼀些判断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(需要返回自身)&#123;</span><br><span class="line">    <span class="keyword">if</span>(作用域中使用 <span class="keyword">this</span> 作为参数)&#123;</span><br><span class="line">        选择 apply</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(作用域中使用 it 作为参数)&#123;</span><br><span class="line">        选择 also</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(不需要返回自身)&#123;</span><br><span class="line">    <span class="keyword">if</span>(作用域中使用 <span class="keyword">this</span> 作为参数)&#123;</span><br><span class="line">        选择 run</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(作用域中使用 it 作为参数)&#123;</span><br><span class="line">        选择 let</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实化类型参数"><a href="#实化类型参数" class="headerlink" title="实化类型参数"></a>实化类型参数</h3><p><strong>泛型类型擦除</strong>：JVM 中的泛型一般是通过类型擦除实现的，也就是说泛型类实例的类型实参在编译时被擦除，在运行时是不会被保留的。基于这样实现的做法是有历史原因的，最大的原因之一是为了兼容 JDK1.5 之前的版本，当然泛型类型擦除也是有好处的，在运行时丢弃了一些类型实参的信息，对于内存占用也会减少很多。</p>
<p>正因为泛型类型擦除原因在业界 Java 的泛型又称伪泛型。因为编译后所有泛型的类型实参类型都会被替换成 Object 类型或者泛型类型形参指定上界约束类的类型。例如： List<Float>、List<String>、List<Student> 在 JVM 运行时 Float、String、Student 都被替换成 Object 类型，如果泛型定义是 List<T extends Student> 那么运行时 T 被替换成 Student 类型。</p>
<p>Kotlin 和 Java 都存在泛型类型擦除的问题，但 Kotlin 可以通过 <code>inline</code> 函数保证使得泛型类的类型实参在运行时能够保留，这样的操作 Kotlin 中把它称为<strong>实化</strong>，对应需要使用 <strong>reified</strong> 关键字。因此，我们可以通过配合 <code>inline + reified</code> 达到「真泛型」的效果。</p>
<p><strong>1、满足实化类型参数函数的必要条件</strong></p>
<ul>
<li>必须是 inline 内联函数，使用 inline 关键字修饰。</li>
<li>泛型类定义泛型形参时必须使用 reified 关键字修饰。</li>
</ul>
<p><strong>2、带实化类型参数的函数基本定义</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">isInstanceOf</span><span class="params">(value: <span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span> = value <span class="keyword">is</span> T</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> obj = User()</span><br><span class="line"><span class="keyword">val</span> instanceOf = isInstanceOf&lt;User&gt;(obj) <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>

<p>对于以上例子，我们可以说类型形参 T 是泛型函数 isInstanceOf 的实化类型参数。</p>
<p><strong>3、原理描述</strong></p>
<p>编译器把实现内联函数的字节码动态插入到每次的调用点。那么实化的原理正是基于这个机制，<strong>每次调用带实化类型参数的函数时，编译器都知道此次调用中作为泛型类型实参的具体类型。所以编译器只要在每次调用时生成对应不同类型实参调用的字节码插入到调用点即可。</strong> 总之一句话很简单，就是带实化参数的函数每次调用都生成不同类型实参的字节码，动态插入到调用点。由于生成的字节码的类型实参引用了具体的类型，而不是类型参数所以不会存在擦除问题。</p>
<p><strong>4、实化类型参数函数不能在 Java 中调用</strong></p>
<p>Kotlin 的实化类型参数函数主要得益于 inline 函数的内联功能，虽然 Java 可以调用普通的内联函数但是失去了内联功能，失去内联功能也就意味实化操作也就化为泡影。</p>
<p><strong>5、实化类型参数函数的使用限制</strong></p>
<ul>
<li>不能使用非实化类型形参作为类型实参调用带实化类型参数的函数。</li>
<li>不能使用实化类型参数创建该类型参数的实例对象。</li>
<li>不能调用实化类型参数的伴生对象方法。</li>
<li>reified 关键字只能标记实化类型参数的内联函数，不能作用于类和属性。</li>
</ul>
<p><strong>6、实化类型参数函数使用例子</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">create</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> RETROFIT.create(T::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> api = create&lt;API&gt;() <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span> = fromJson(json, T::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = Gson().fromJson&lt;User&gt;(json) <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>

<h3 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h3><p>Kotlin 中也使用 class 关键字定义类，所有类都继承于 Any 类，类似于 Java 中 Object 类的概念。类实例化的形式也与 Java 一样，但是去掉了 new 关键字。</p>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>类的构造器分为主构造器（primary constructor）和次级构造器（secondary constructor），前者只能有一个，而后者可以有多个。如果两者都未指定，则默认为无参数的主构造器。</p>
<p>主构造器是属于类头的一部分，用 constructor 关键字定义，如果没有被「可见性修饰符」或者「注解」标注，constructor 可省略。由于主构造器不能包含任何代码，初始化代码需要单独写在 init 代码块中，主构造器的参数只能在 init 代码块和变量初始化时使用。</p>
<p>次级构造器也是用 constructor 关键字定义，必须要直接或间接代理主构造器。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(name: String) &#123; <span class="comment">// 主构造器</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(id: <span class="built_in">Int</span>, name: String) : <span class="keyword">this</span>(name) &#123; <span class="comment">// 次级构造器</span></span><br><span class="line">        <span class="keyword">this</span>.id = id</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主构造器中的参数加上 val 或者 var 修饰，那么参数就变成类的成员变量，如果参数和类原来的成员变量一样，那么对应原来的成员变量就要去掉。因此，以上代码一般可以简化为以下代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>类继承使用符号 “:” 表示，接口实现也一样，不做原本 Java 中的 extends 和 implement 关键字区分。Kotlin 中取消了 final 关键字，所有类默认都是被 final 修饰，不能被继承。Kotlin 中新增了 open 关键字，被 open 或者 abstract 修饰的类才可以被继承。</p>
<h4 id="单例与伴随对象"><a href="#单例与伴随对象" class="headerlink" title="单例与伴随对象"></a>单例与伴随对象</h4><p>Kotlin 使用关键词 object 定义单例类。这里需要注意，是全小写。单例类访问直接使用类名，无构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> LogUtil &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;tag&quot;</span>, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可通过 AS 工具栏 Tools –&gt; Kotlin –&gt; Show Kotlin Bytecode, 点击右侧的 Decompile 来把当前 Kotlin 代码转换为 Java 代码，来验证以上 object 对象是否转换成 Java 中的单例类。</p>
</blockquote>
<p>Java 中使用 static 标识一个类里的静态属性或方法。Kotlin 中没有 static 关键字，改为使用伴随对象，用 companion 修饰单例类 object, 来实现静态属性或方法功能。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoginCache</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> USER_NAME = <span class="string">&quot;user_name&quot;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> PASSWORD = <span class="string">&quot;password&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">saveLoginInfo</span><span class="params">(userName: <span class="type">String</span>, password: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginCache.saveLoginInfo(<span class="string">&quot;ZhangSan&quot;</span>,<span class="string">&quot;123456&quot;</span>) <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>

<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>在 Kotlin 中，内部类默认是静态内部类，通过 <code>inner</code> 关键字声明为嵌套内部类。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>形式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> : OnItemCLickListener &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">btnLogin.setOnClickListener(<span class="keyword">object</span> :View.OnClickListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上匿名内部类转换成的 lambda 表达式如下：</span></span><br><span class="line">btnLogin.setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>const 必须修饰 val。</li>
<li>const 只允许在 top-level 级别和 object 中声明。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> LogUtil &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> TAG: String = <span class="string">&quot;LogUtil&quot;</span></span><br><span class="line">    <span class="keyword">val</span> msg: String = <span class="string">&quot;msg&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 Kotlin 代码转换成的 Java 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略了部分不大相关代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LogUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;LogUtil&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，const val 可见性为 public static final, 可以直接访问。val 可见性为 private static final, 并且 val 会生成对应属性的 getter 方法，通过方法调用访问。当定义常量时，出于效率考虑，应该使用 const val 方式，避免频繁函数调用。const 修饰的静态变量又称为<strong>编译器常量</strong>。</p>
<h3 id="声明抽象类-接口-枚举-注解"><a href="#声明抽象类-接口-枚举-注解" class="headerlink" title="声明抽象类&#x2F;接口&#x2F;枚举&#x2F;注解"></a>声明抽象类&#x2F;接口&#x2F;枚举&#x2F;注解</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span></span><br><span class="line"><span class="comment">// 声明接⼝</span></span><br><span class="line"><span class="keyword">interface</span></span><br><span class="line"><span class="comment">// 声明注解</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span></span><br><span class="line"><span class="comment">// 声明枚举</span></span><br><span class="line">enmu <span class="keyword">class</span></span><br></pre></td></tr></table></figure>

<h3 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h3><p>Kotlin 不需要使用 <code>try-catch</code> 强制捕获异常。</p>
<h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 [类名::<span class="keyword">class</span>] 获取的是 Kotlin 的类型 KClass</span><br><span class="line">使用 [类名::<span class="keyword">class</span>.java] 获取的是 Java 的类型</span><br><span class="line"></span><br><span class="line">startActivity(Intent(<span class="keyword">this</span>, MainActivity::<span class="keyword">class</span>.java))</span><br></pre></td></tr></table></figure>

<h3 id="setter-getter"><a href="#setter-getter" class="headerlink" title="setter&#x2F;getter"></a>setter&#x2F;getter</h3><p>在 Kotlin 声明属性的时候（没有使用 private 修饰），会自动生成一个私有属性和一对公开的 setter&#x2F;getter 方法。在写 setter&#x2F;getter 的时候使⽤ field 来代替内部的私有属性（防⽌递归栈溢出）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() = field <span class="comment">// 默认实现方式，可省略</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123; <span class="comment">// 默认实现方式，可省略</span></span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">get</span>() = <span class="number">18</span> <span class="comment">// 获取的值一直都是 18，不会改变</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JvmXxx-相关注解"><a href="#JvmXxx-相关注解" class="headerlink" title="JvmXxx 相关注解"></a>JvmXxx 相关注解</h3><h4 id="JvmField"><a href="#JvmField" class="headerlink" title="JvmField"></a>JvmField</h4><p>通过 <code>@JvmField</code> 注解可以让编译器只生成一个 public 的成员属性，不生成对应的 setter&#x2F;getter 方法。</p>
<h4 id="JvmName"><a href="#JvmName" class="headerlink" title="JvmName"></a>JvmName</h4><p>顶层函数在文件中定义函数和属性，会直接生成静态的成员，在 Java 中通过「文件名Kt」来访问，同时可以通过 <code>@file:JvmName</code> 注解来修改这个类名。注解要写在包名前面才会起作用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">&quot;AppCache&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.zch.kotlin.biz1</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mToken: String? = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveToken</span><span class="params">(token: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    mToken = token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 中访问方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    AppCacheKt.saveToken(<span class="string">&quot;abc123&quot;</span>); <span class="comment">// 原来的访问方式</span></span><br><span class="line">    AppCache.saveToken(<span class="string">&quot;abc123&quot;</span>); <span class="comment">// 加了 @file:JvmName 注解后的访问方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JvmStatic"><a href="#JvmStatic" class="headerlink" title="JvmStatic"></a>JvmStatic</h4><p>如果将命名对象或伴生对象中定义的函数注解为 <code>@JvmStatic</code> ，Kotlin 会为这些函数生成静态方法。</p>
<p><code>命名对象中的 @JvmStatic</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SizeUtil &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dp2px</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sp2px</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSizeUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 之前的访问方式</span></span><br><span class="line">    SizeUtil.INSTANCE.dp2px();</span><br><span class="line">    SizeUtil.INSTANCE.sp2px();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加了 @JvmStatic 注解后，dp2px 变成了静态方法</span></span><br><span class="line">    SizeUtil.dp2px();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>伴生对象中的 @JvmStatic</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">sayYes</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">sayNo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUtil</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 之前的访问方式</span></span><br><span class="line">    Util.Companion.sayYes();</span><br><span class="line">    Util.Companion.sayNo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加了 <span class="doctag">@JvmStatic</span> 注解后，Util 生成了静态方法 sayYes，</span></span><br><span class="line"><span class="comment">     * 该静态方法直接访问 Companion 的 sayYes()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Util.sayYes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@JvmStatic</code> 注解也可以应用于对象或伴生对象的属性，使其 getter 和 setter 方法成为该对象或包含伴生对象的类的静态成员。</p>
</blockquote>
<h4 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="JvmOverloads"></a>JvmOverloads</h4><p>在 Kotlin 中调用默认参数值的方法或者构造函数是完全没问题的，Java 中调用相应 Kotlin 方法时，是必须输入所有参数的值的，Kotlin 中默认参数我们无法使用。而当加上 <code>@JvmOverloads</code>, Kotlin 编译器生成的字节码中有对应的重载方法，我们就可以通过 Java 的重载方式来使用 Kotlin 的代码了，不必要输入所有的参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParamView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span>) : LinearLayout(context, attrs, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 Kotlin 的自定义控件加上 <code>@JvmOverloads</code> 后，相当于 Java 中的以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamView</span> <span class="keyword">extends</span> <span class="title class_">LinearLayout</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParamView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParamView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParamView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Kotlin 中构造函数、顶级函数、类中方法，静态方法（@Jvmstatic 修饰）均可采用 <code>@JvmOverloads</code> 生成对应重载方法。</p>
</blockquote>
<h3 id="注解使用处目标"><a href="#注解使用处目标" class="headerlink" title="注解使用处目标"></a>注解使用处目标</h3><p>当某个元素可能会包含多种内容（例如构造属性，成员属性），使用注解时可以通过「注解使⽤处⽬标」，让注解对⽬标发⽣作⽤，例如 @file: 、 @get: 、@set: 等。  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="meta">@get:JvmName</span>(<span class="string">&quot;instance&quot;</span>)</span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> instance: Application</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        instance = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">App.Companion.getInstance(); <span class="comment">// java 中原来调用方式</span></span><br><span class="line">App.instance(); <span class="comment">// java 中现在调用方式</span></span><br></pre></td></tr></table></figure>

<h3 id="Elvis-操作符"><a href="#Elvis-操作符" class="headerlink" title="Elvis 操作符"></a>Elvis 操作符</h3><p>可通过 <code>?:</code> 的操作来简化 <code>if null</code> 操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lesson.date 为空时使⽤默认值</span></span><br><span class="line"><span class="keyword">val</span> date = lesson.date?: <span class="string">&quot;⽇期待定&quot;</span></span><br><span class="line"><span class="comment">// lesson.state 为空时提前返回函数</span></span><br><span class="line"><span class="keyword">val</span> state = lesson.state?: <span class="keyword">return</span></span><br><span class="line"><span class="comment">// lesson.content 为空时抛出异常</span></span><br><span class="line"><span class="keyword">val</span> content = lesson.content ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;content expected&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="空指针安全"><a href="#空指针安全" class="headerlink" title="空指针安全"></a>空指针安全</h3><p>Kotlin 中，当我们定义一个变量时，其默认就是非空类型。如果你直接尝试给他赋值为 null, 编译器会直接报错。Kotlin 中将符号 “?” 定义为安全调用操作符。变量类型后面跟 ? 号定义，表明这是一个可空类型。同样的，在调用子属性和函数时，也可以用字符 ? 进行安全调用。Kotlin 的编译器会在写代码时就检查非空情况。</p>
<p>Kotlin 还提供 “!!” 双感叹号操作符来强制调用对象的属性和方法，无视其是否非空。这是一个挺危险的操作符，除非有特殊需求，否则为了远离 NPE, 还是少用为妙。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tvContent: TextView <span class="comment">// 非空类型</span></span><br><span class="line"><span class="keyword">var</span> tvContent: TextView? <span class="comment">// 可空类型</span></span><br><span class="line"></span><br><span class="line">!! <span class="comment">// 强行调用符</span></span><br><span class="line">? <span class="comment">// 安全调用符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1: String = <span class="string">&quot;abc&quot;</span></span><br><span class="line">s1 = <span class="literal">null</span> <span class="comment">// 这里编译器会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2: String? = <span class="string">&quot;abc&quot;</span></span><br><span class="line">s2 = <span class="literal">null</span> <span class="comment">// 编译器不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l1 = s1.length <span class="comment">// 可正常编译</span></span><br><span class="line"><span class="keyword">var</span> l2 = s2.length <span class="comment">// 没有做非空判断，编译器检查报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s2 != <span class="literal">null</span>) s2.length <span class="comment">// Java 式的判空方案</span></span><br><span class="line">s2?.length <span class="comment">// Kotlin 的安全调用操作符 ?。当 s2 为 null 时，s2?.length 也为 null</span></span><br><span class="line"></span><br><span class="line">s2!!.length <span class="comment">// 可能会导致 NPE</span></span><br></pre></td></tr></table></figure>

<h3 id="lateinit-关键字"><a href="#lateinit-关键字" class="headerlink" title="lateinit 关键字"></a>lateinit 关键字</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、lateinit 只能修饰 var 可读可写变量。</span></span><br><span class="line"><span class="comment"> * 2、lateinit 关键字声明的变量类型必须是不可空类型。</span></span><br><span class="line"><span class="comment"> * 3、lateinit 声明的变量不能有初始值。</span></span><br><span class="line"><span class="comment"> * 4、lateinit 声明的变量不能是基本数据类型。</span></span><br><span class="line"><span class="comment"> * 5、在构造器中初始化的属性不需要 lateinit 关键字。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> tvContent: TextView</span><br></pre></td></tr></table></figure>

<h3 id="data-class"><a href="#data-class" class="headerlink" title="data class"></a>data class</h3><p>数据类通常都是由多个属性和对应的 getter、setter 组成。当有大量多属性时，不仅这些类会因为大量的 getter 和 setter 方法而行数爆炸，也使整个工程方法数骤增。</p>
<p>Kotlin 中做了这层特性优化，提供了数据类的简单实现。不用再写 getter、setter 方法，这些都由编译器背后去做，你得到的是一个清爽干净的数据类。数据类用 <code>data class</code> 声明。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Student</span>(</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">var</span> name: String,</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>把这个数据类反编译成 Java 代码可知，数据类除了为我们生成了 getter、setter（val 声明的变量不生成 setter 方法）、构造函数外，还有以下方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">equals() / hashCode()</span><br><span class="line">toString()</span><br><span class="line">componentN()...</span><br><span class="line">copy()</span><br></pre></td></tr></table></figure>

<p><code>copy 函数</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Student copy(int id, String name, int age) &#123;</span><br><span class="line">    <span class="keyword">return</span> new Student(id, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当要复制一个对象，只改变一些属性，但其余不变，copy() 就是为此而生。</p>
<p><code>componentN 函数-解构声明（Destructuring Declarations）</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> int component1() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String component2() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> int component3() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器为数据类（data class）自动声明 componentN() 函数，可直接用解构声明。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="number">101</span>, <span class="string">&quot;ZhangSan&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">val</span> (id, name, age) = student <span class="comment">// 自动赋值给 id, name, age</span></span><br><span class="line">println(<span class="string">&quot;id=<span class="variable">$id</span>, name=<span class="variable">$name</span>, age=<span class="variable">$age</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="相等性"><a href="#相等性" class="headerlink" title="相等性"></a>相等性</h3><p><code>两个等号==和三个等号===</code></p>
<p>两个等号 <code>==</code>：比较的是<strong>对象的内容</strong>是否相同，相当于 Java 的 equals()。<code>==</code> 的否定形式为 <code>!=</code> 。</p>
<p>三个等号 <code>===</code>：比较的是<strong>对象的地址</strong>是否相同（即判断是否为同一对象），相当于 Java 的 &#x3D;&#x3D;。<code>===</code> 的否定形式为 <code>!==</code> 。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student1 = Student(<span class="number">101</span>, <span class="string">&quot;ZhangSan&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">val</span> student2 = Student(<span class="number">101</span>, <span class="string">&quot;ZhangSan&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">if</span> (student1 == student2) &#123; <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (student1 === student2) &#123; <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h3><p>通过 operator 修饰「特定函数名」的函数，例如 plus 、get, 可以达到重载运算符的效果。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody><tr>
<td>a + b</td>
<td>a.plus(b)</td>
</tr>
<tr>
<td>a - b</td>
<td>a.minus(b)</td>
</tr>
<tr>
<td>a * b</td>
<td>a.times(b)</td>
</tr>
<tr>
<td>a &#x2F; b</td>
<td>a.div(b)</td>
</tr>
</tbody></table>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托，也就是委托模式，它是 23 种经典设计模式中的一种，又名<code>代理模式</code>，在委托模式中，有 2 个对象参与同一个请求的处理，接受请求的对象将请求委托给另一个对象来处理。委托模式中，有三个角色：约束、委托对象和被委托对象。Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 <code>by</code> 实现委托。</p>
<ul>
<li><strong>约束</strong>：约束是接口或者抽象类，它定义了通用的业务类型，也就是需要被代理的业务。</li>
<li><strong>被委托对象</strong>：具体的业务逻辑执行者。</li>
<li><strong>委托对象</strong>：负责对真正角色的应用，将约束类定义的业务委托给具体的委托对象。</li>
</ul>
<h4 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h4><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约束类，我们约定的业务</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGamePlayer</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">()</span></span> <span class="comment">// 打游戏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被委托对象，实现了我们约定的业务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealGamePlayer</span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String) : IGamePlayer &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;name&#125;</span>开始打游戏&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托对象，通过关键字 by 建立委托类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelegateGamePlayer</span>(<span class="keyword">private</span> <span class="keyword">val</span> player: IGamePlayer) : IGamePlayer <span class="keyword">by</span> player</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> realGamePlayer = RealGamePlayer(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> delegateGamePlayer = DelegateGamePlayer(realGamePlayer)</span><br><span class="line">    delegateGamePlayer.play() <span class="comment">// 输出：张三开始打游戏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 DelegateGamePlayer 声明中，by 子句表示，将 player 保存在 DelegateGamePlayer 的对象实例内部，而且编译器将会生成继承自 IGamePlayer 接口的所有方法，并将调用转发给 player。</p>
<blockquote>
<p> 可以通过类委托的模式来减少继承。</p>
</blockquote>
<h4 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h4><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p>
<p>属性委托语法格式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> &lt;属性名&gt;: &lt;类型&gt; <span class="keyword">by</span> &lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>var&#x2F;val：属性类型(可变&#x2F;只读)。</li>
<li>属性名：属性名称。</li>
<li>类型：属性的数据类型。</li>
<li>表达式：委托代理类。</li>
</ul>
<p>by 关键字之后的表达式就是委托，属性的 get() 方法（以及 set() 方法）将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口，但必须提供 getValue() 函数（对于 var 属性，还需要 setValue() 函数）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被委托类（委托代理类）</span></span><br><span class="line"><span class="comment"> * 该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，property 为进行委托的属性的对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$thisRef</span>, 这里委托了 <span class="subst">$&#123;property.name&#125;</span> 属性&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$thisRef</span> 的 <span class="subst">$&#123;property.name&#125;</span> 属性赋值为 <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> token: String <span class="keyword">by</span> Delegate()</span><br><span class="line">    println(token) <span class="comment">// 访问该属性，调用 getValue() 函数</span></span><br><span class="line"></span><br><span class="line">    token = <span class="string">&quot;xxx&quot;</span>   <span class="comment">// 调用 setValue() 函数</span></span><br><span class="line">    println(token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的参数解释如下：</p>
<ul>
<li><code>thisRef</code> —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型。</li>
<li><code>property</code> —— 必须是类型 <code>KProperty&lt;*&gt;</code> 或其超类型。</li>
<li><code>value</code> —— 必须与属性同类型或者是它的子类型。</li>
</ul>
<h4 id="属性委托的另一种实现方式"><a href="#属性委托的另一种实现方式" class="headerlink" title="属性委托的另一种实现方式"></a>属性委托的另一种实现方式</h4><p>Kotlin 标准库中声明了 2 个含所需 <code>operator</code> 方法的 <code>ReadOnlyProperty / ReadWriteProperty</code> 接口。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadOnlyProperty</span>&lt;<span class="type">in R, out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadWriteProperty</span>&lt;<span class="type">in R, T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>被委托类</code> 实现这两个接口其中之一就可以了，<code>val</code> 属性实现 <code>ReadOnlyProperty</code>, <code>var</code> 属性实现 <code>ReadWriteProperty</code>。 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate2</span> : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any?, String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> token2: String <span class="keyword">by</span> Delegate2()</span><br></pre></td></tr></table></figure>

<h4 id="标准库中提供的几个委托"><a href="#标准库中提供的几个委托" class="headerlink" title="标准库中提供的几个委托"></a>标准库中提供的几个委托</h4><ul>
<li>延迟属性（lazy）: 其值只在首次访问时计算。</li>
<li>可观察属性（observable）: 监听器会收到有关此属性变更的通知。</li>
<li>把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。</li>
</ul>
<p><strong>1、延迟属性 lazy</strong></p>
<p>lazy() 是一个函数，接受一个 Lambda 表达式作为参数，返回一个 Lazy <T> 实例的函数，返回的实例可以作为实现延迟属性的委托：第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果，后续调用 get() 只是返回记录的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">&quot;computed!&quot;</span>) <span class="comment">// 第一次调用输出，第二次调用不执行</span></span><br><span class="line">    <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(lazyValue) <span class="comment">// 第一次执行，执行两次输出表达式</span></span><br><span class="line">    println(lazyValue) <span class="comment">// 第二次执行，只输出返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行输出结果</span></span><br><span class="line">computed!</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p><strong>2、可观察属性 Observable</strong></p>
<p>observable 可以用于实现观察者模式。</p>
<p>Delegates.observable() 函数接受两个参数：第一个是初始化值，第二个是属性值被修改时的回调处理器 onChange。回调处理器有三个参数：被赋值的属性、旧值和新值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.properties.Delegates</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;A&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">        println(<span class="string">&quot;旧值：<span class="variable">$oldValue</span> -&gt; 新值：<span class="variable">$newValue</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User()</span><br><span class="line">    user.name = <span class="string">&quot;B&quot;</span></span><br><span class="line">    user.name = <span class="string">&quot;C&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行输出结果</span></span><br><span class="line">旧值：A -&gt; 新值：B</span><br><span class="line">旧值：B -&gt; 新值：C</span><br></pre></td></tr></table></figure>

<p><strong>vetoable 函数</strong>：<code>vetoable</code> 与 <code>observable</code> 一样，可以观察属性值的变化，不同的是，<code>vetoable</code> 可以通过<code>处理器函数来决定属性值是否生效</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个 Int 类型的属性 vetoableProp, 如果新的值比旧值大，则生效，否则不生效。</span></span><br><span class="line"><span class="keyword">var</span> vetoableProp: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.vetoable(<span class="number">0</span>)&#123; _, oldValue, newValue -&gt;</span><br><span class="line">    <span class="comment">// 如果新的值大于旧值，则生效</span></span><br><span class="line">    newValue &gt; oldValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、把属性储存在映射中</strong></p>
<p>一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他“动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>  <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构造函数接受一个映射参数</span></span><br><span class="line">    <span class="keyword">val</span> user = User(mapOf(</span><br><span class="line">        <span class="string">&quot;name&quot;</span> to <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>  to <span class="number">18</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取映射值</span></span><br><span class="line">    println(user.name)</span><br><span class="line">    println(user.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合中函数式-API-操作符"><a href="#集合中函数式-API-操作符" class="headerlink" title="集合中函数式 API 操作符"></a>集合中函数式 API 操作符</h3><h4 id="筛选过滤类"><a href="#筛选过滤类" class="headerlink" title="筛选过滤类"></a>筛选过滤类</h4><h5 id="slice-系列"><a href="#slice-系列" class="headerlink" title="slice 系列"></a>slice 系列</h5><p>操作符可以取集合中一部分元素或者某个元素，最后组合成一个新元素。</p>
<ul>
<li><p>**<code>slice(indices: IntRange)</code>**：指定切片的起始位置和终止位置，将范围内的元素切出加入到新集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).slice(IntRange(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">println(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>slice(indices: Iterable&lt;Int&gt;)</code>**：指定下标分别切出对应的元素，放入新集合中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).slice(IntRange(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">println(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list2 = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).slice(listOf(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">println(list2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="filter-系列"><a href="#filter-系列" class="headerlink" title="filter 系列"></a>filter 系列</h5><ul>
<li><p>**<code>filter(predicate: (T) -&gt; Boolean)</code>**：从一个集合筛选出符合条件的元素，并以一个新集合返回。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">println(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>filterTo(destination: C, predicate: (T) -&gt; Boolean)</code>**：从多个集合筛选出符合条件的元素，并最终用一个集合进行收集从每个集合筛选出的元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numberList1 = listOf(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">val</span> numberList2 = listOf(<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">val</span> numberList3 = listOf(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// filterTo 的 destination 是一个可变集合类型，所以这里使用 mutableListOf 初始化</span></span><br><span class="line"><span class="keyword">val</span> newNumberList = mutableListOf&lt;<span class="built_in">Int</span>&gt;().apply &#123;</span><br><span class="line">    numberList1.filterTo(<span class="keyword">this</span>) &#123;</span><br><span class="line">        it % <span class="number">5</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    numberList2.filterTo(<span class="keyword">this</span>) &#123;</span><br><span class="line">        it % <span class="number">5</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    numberList3.filterTo(<span class="keyword">this</span>) &#123;</span><br><span class="line">        it % <span class="number">20</span> == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(newNumberList)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">15</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>filterIndexed(predicate: (index: Int, T) -&gt; Boolean)</code>**：需要集合元素 <code>index</code> 参与筛选条件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = listOf(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>).filterIndexed &#123; index, item -&gt;</span><br><span class="line">    index &gt; <span class="number">2</span> &amp;&amp; item % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">12</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>filterIndexedTo(destination: C, predicate: (index: Int, T) -&gt; Boolean)</code>**：从多个集合筛选出符合条件的元素，筛选条件需要 <code>index</code>，并最终用一个集合进行收集从每个集合筛选出的元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">listOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>).filterIndexedTo(result) &#123; index, item -&gt;</span><br><span class="line">    index == item</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>filterIsInstance()</code>**：一个抽象类集合中含有多种子类型的元素，可以很方便筛选对应子类型的元素，并组成一个集合返回。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="string">&quot;4&quot;</span>, <span class="number">5f</span>, <span class="number">6.0</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = list.filterIsInstance&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>filterIsInstanceTo(destination: C)</code>**：适用于筛选多个集合的情况。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3</span>, <span class="string">&quot;4&quot;</span>, <span class="number">5f</span>, <span class="number">6.0</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = mutableListOf&lt;String&gt;()</span><br><span class="line">list.filterIsInstanceTo(result)</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>filterNot(predicate: (T) -&gt; Boolean)</code><strong>、</strong><code>filterNotTo(destination: C, predicate: (T) -&gt; Boolean)</code>**：从一个集合筛选出符合条件之外的元素，并以一个新集合返回。它是 filter 操作符取反操作。</p>
</li>
<li><p>**<code>filterNotNull()</code><strong>、</strong><code>filterNotNullTo(destination: C)</code>**：filterNotNull 操作符可以过滤集合中为 null 的元素。同理 filterNotNullTo 才是真正过滤操作，但是需要从外部传入一个可变集合。</p>
</li>
</ul>
<h5 id="drop-系列"><a href="#drop-系列" class="headerlink" title="drop 系列"></a>drop 系列</h5><ul>
<li><p>**<code>drop(n: Int)</code>**：把集合元素去除一部分，drop 是顺序地删除，n 则表示顺序删除几个元素，最后返回剩余元素集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).drop(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>dropLast(n: Int)</code>**：根据传入数值 n，表示从右到左倒序地删除 n 个集合中的元素，并返回集合中剩余的元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).dropLast(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>dropWhile(predicate: (T) -&gt; Boolean)</code>**：从集合的第一项开始去掉满足条件元素，这样操作一直持续到出现第一个不满足条件元素出现为止，返回剩余元素（可能剩余元素有满足条件的元素）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>).dropWhile &#123; it &lt; <span class="number">20</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>dropLastWhile(predicate: (T) -&gt; Boolean)</code>**：从集合的最后一项开始去掉满足条件元素，这样操作一直持续到出现第一个不满足条件元素出现为止，返回剩余元素（可能剩余元素有满足条件的元素）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>).dropLastWhile &#123; it &lt; <span class="number">20</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="take-系列"><a href="#take-系列" class="headerlink" title="take 系列"></a>take 系列</h5><ul>
<li><p>**<code>take(n: Int)</code>**：从原集合的第一项开始顺序取集合的元素，取 n 个元素，最后返回取出这些元素的集合。换句话说就是取集合前 n 个元素组成新的集合返回。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>).take(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>takeLast(n: Int)</code>**：从原集合的最后一项开始倒序取集合的元素，取 n 个元素，最后返回取出这些元素的集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>).takeLast(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>takeLastWhile(predicate: (T) -&gt; Boolean)</code>**：从集合的最后一项开始取出满足条件元素，这样操作一直持续到出现第一个不满足条件元素出现为止，暂停取元素，返回取出元素的集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>).takeLastWhile &#123; it &lt; <span class="number">20</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>takeWhile(predicate: (T) -&gt; Boolean)</code>**：从集合的第一项开始取出满足条件元素，这样操作一直持续到出现第一个不满足条件元素出现为止，暂停取元素，返回取出元素的集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>).takeWhile &#123; it &lt; <span class="number">20</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="distinct-系列"><a href="#distinct-系列" class="headerlink" title="distinct 系列"></a>distinct 系列</h5><ul>
<li><p><code>distinct</code>：去除集合中的重复元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).distinct())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>distinctBy(selector: (T) -&gt; K)</code>**：根据操作元素后的结果去除重复元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>).distinctBy &#123; it % <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="并集类操作符"><a href="#并集类操作符" class="headerlink" title="并集类操作符"></a>并集类操作符</h4><h5 id="any、all、count、none-系列"><a href="#any、all、count、none-系列" class="headerlink" title="any、all、count、none 系列"></a>any、all、count、none 系列</h5><ul>
<li><p>**<code>any()</code>**：判断是不是一个集合，若是，则再判断集合是否为空。若为空则返回 false，反之返回 true。若不是集合，则返回 hasNext。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>).any())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>any(predicate: (T) -&gt; Boolean)</code>**：判断集合中是否存在满足条件的元素。若存在则返回 true，反之返回 false。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">5</span>).any &#123; it &gt; <span class="number">30</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>all(predicate: (T) -&gt; Boolean)</code>**：判断集合中的所有元素是否都满足条件。若是则返回 true，反之则返回 false。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">0</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">50</span>).all &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>count()</code><strong>、</strong><code>count(predicate: (T) -&gt; Boolean)</code>**：返回集合中的元素个数或查询集合中满足条件的元素个数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">0</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">50</span>).count())</span><br><span class="line">println(listOf(<span class="number">0</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">50</span>).count &#123; it &gt; <span class="number">10</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>none()</code><strong>、</strong><code>none(predicate: (T) -&gt; Boolean)</code>**：如果一个集合是空集合，返回 true 或者集合中没有满足条件的元素，则返回 true。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">0</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">50</span>).none()) </span><br><span class="line">println(listOf(<span class="number">0</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">50</span>).none &#123; it &gt; <span class="number">50</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="fold-系列"><a href="#fold-系列" class="headerlink" title="fold 系列"></a>fold 系列</h5><ul>
<li><p>**<code>fold(initial: R, operation: (acc: R, T) -&gt; R)</code>**：在一个初始值的基础上，从第一项到最后一项通过一个函数累计所有的元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>).fold(<span class="number">10</span>) &#123; result, element -&gt;</span><br><span class="line">    result + element</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>foldIndexed(initial: R, operation: (index: Int, acc: R, T) -&gt; R)</code>**：在一个初始值的基础上，从第一项到最后一项通过一个函数累计所有的元素，该函数的参数可以包含元素索引。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>).foldIndexed(<span class="string">&quot;Say&quot;</span>) &#123; index, result, element -&gt;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$result</span> <span class="variable">$element</span><span class="variable">$index</span>&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">Say h0 e1 l2 l3 o4</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>foldRight(initial: R, operation: (T, acc: R) -&gt; R)</code>**：在一个初始值的基础上，从最后项到第一项通过一个函数累计所有的元素，与 fold 类似，不过是从最后一项开始累计。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).foldRight(<span class="string">&quot;Say&quot;</span>) &#123; element, result -&gt;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$result</span> <span class="variable">$element</span>&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">Say <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -&gt; R)</code>**：在一个初始值的基础上，从最后一项到第一项通过一个函数累计所有的元素，该函数的参数可以包含元素索引。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).foldRightIndexed(<span class="string">&quot;Say&quot;</span>) &#123; index, element, result -&gt;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$result</span> <span class="variable">$element</span>-<span class="variable">$index</span>&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">Say <span class="number">3</span>-<span class="number">2</span> <span class="number">2</span>-<span class="number">1</span> <span class="number">1</span>-<span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="forEach-系列"><a href="#forEach-系列" class="headerlink" title="forEach 系列"></a>forEach 系列</h5><ul>
<li><p>**<code>forEach(action: (T) -&gt; Unit)</code>**：集合元素的遍历操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).forEach &#123;</span><br><span class="line">    print(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>forEachIndexed(action: (index: Int, T) -&gt; Unit)</code>**：集合中带元素下标的遍历操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listOf(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).forEachIndexed &#123; index, s -&gt;</span><br><span class="line">    print(<span class="string">&quot;<span class="variable">$index</span>-<span class="variable">$s</span> &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">0</span>-<span class="number">1</span> <span class="number">1</span>-<span class="number">2</span> <span class="number">2</span>-<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="max、min-系列"><a href="#max、min-系列" class="headerlink" title="max、min 系列"></a>max、min 系列</h5><ul>
<li><p>**<code>maxOrNull()</code>**：获取集合中最大的元素，若为空元素集合，则返回 null。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;A&quot;</span>).maxOrNull())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">C</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>maxByOrNull(selector: (T) -&gt; R)</code>**：根据给定的函数返回最大的一项，如果没有则返回 null。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(-<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>).maxByOrNull &#123;</span><br><span class="line">    it * -<span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">-<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>maxWithOrNull(comparator: Comparator&lt;in T&gt;)</code>**：接受一个 Comparator 对象并且根据此 Comparator 对象返回最大元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="string">&quot;-20&quot;</span>, <span class="string">&quot;-102&quot;</span>, <span class="string">&quot;0&quot;</span>).maxWithOrNull(compareBy &#123;</span><br><span class="line">    it.length</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">-<span class="number">102</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>min 操作符作用与 max 相反，包括 minBy 和 minWith。</p>
</blockquote>
<h5 id="reduce-系列"><a href="#reduce-系列" class="headerlink" title="reduce 系列"></a>reduce 系列</h5><ul>
<li><p>**<code>reduce(operation: (acc: S, T) -&gt; S)</code>**：从集合中的第一项到最后一项的累计操作，与 fold 操作符的区别是没有初始值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="string">&quot;Nice&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;meet&quot;</span>, <span class="string">&quot;you&quot;</span>).reduce &#123; result, element -&gt;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$result</span> <span class="variable">$element</span>&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">Nice to meet you</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中 reduceIndexed，reduceRight，reduceRightIndexed 操作符都与前述的 fold 相关操作符类似，只是没有初始值。</p>
</blockquote>
</li>
<li><p>**<code>reduceOrNull(operation: (acc: S, T) -&gt; S)</code>**：从集合中的第一项到最后一项的累计操作，如果集合为空，返回 null。</p>
<blockquote>
<p>reduceRightOrNull 操作符作用等价于 reduceRight，不同的是当集合为空，返回 null。</p>
</blockquote>
</li>
</ul>
<h5 id="sum-系列"><a href="#sum-系列" class="headerlink" title="sum 系列"></a>sum 系列</h5><ul>
<li><p>**<code>sum()</code>**：计算集合中所有元素累加的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).sum())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>sumOf(selector: (T) -&gt; Int)</code>**：计算集合所有元素通过某个函数转换后数据之和。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).sumOf &#123; it * <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="映射类操作符"><a href="#映射类操作符" class="headerlink" title="映射类操作符"></a>映射类操作符</h4><h5 id="flatMap-系列"><a href="#flatMap-系列" class="headerlink" title="flatMap 系列"></a>flatMap 系列</h5><ul>
<li><p>**<code>flatMap(transform: (T) -&gt; Iterable&lt;R&gt;)</code>**：根据条件合并两个集合，组成一个新的集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">println(strList.flatMap &#123; listOf(it.plus(<span class="string">&quot;1&quot;</span>)) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[A1, B1, C1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>flatMapTo(destination: C, transform: (T) -&gt; Iterable&lt;R&gt;)</code>**：多个集合的条件合并。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> strList2 = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> resultList = mutableListOf&lt;String&gt;().apply &#123;</span><br><span class="line">    strList.flatMapTo(<span class="keyword">this</span>) &#123;</span><br><span class="line">        listOf(it.plus(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    strList2.flatMapTo(<span class="keyword">this</span>) &#123;</span><br><span class="line">        listOf(it.plus(<span class="string">&quot;2&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(resultList)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[A1, B1, C1, a2, b2, c2]</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="group-系列"><a href="#group-系列" class="headerlink" title="group 系列"></a>group 系列</h5><ul>
<li><p>**<code>groupBy(keySelector: (T) -&gt; K)</code>**：分组操作符，根据条件将集合拆分为一个 Map 类型集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.groupBy &#123; <span class="keyword">if</span> (it.startsWith(<span class="string">&quot;Java&quot;</span>)) <span class="string">&quot;MyJava&quot;</span> <span class="keyword">else</span> <span class="string">&quot;MyKotlin&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">&#123;MyJava=[Java, JavaScript], MyKotlin=[Kotlin, C, C++]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>groupByTo(destination: M, keySelector: (T) -&gt; K)</code>**：分组操作，适用于多个集合的分组操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> strList2 = listOf(<span class="string">&quot;15&quot;</span>, <span class="string">&quot;223&quot;</span>, <span class="string">&quot;45&quot;</span>, <span class="string">&quot;520&quot;</span>, <span class="string">&quot;18&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> mutableMap = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;().apply &#123;</span><br><span class="line">    strList.groupByTo(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.startsWith(<span class="string">&quot;Java&quot;</span>)) <span class="string">&quot;Java&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Not Java&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    strList2.groupByTo(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.contains(<span class="string">&quot;2&quot;</span>)) <span class="string">&quot;2&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Not 2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(mutableMap)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">&#123;Java=[Java, JavaScript], Not Java=[Kotlin, C, C++], Not <span class="number">2</span>=[<span class="number">15</span>, <span class="number">45</span>, <span class="number">18</span>], <span class="number">2</span>=[<span class="number">223</span>, <span class="number">520</span>]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>groupingBy(crossinline keySelector: (T) -&gt; K)</code>**：对元素进行分组，然后一次将操作应用于所有分组。适用于对集合复杂分组的情况。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.groupingBy &#123; it.startsWith(<span class="string">&quot;Java&quot;</span>) &#125;.eachCount())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">&#123;<span class="literal">true</span>=<span class="number">2</span>, <span class="literal">false</span>=<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>Grouping</code> 支持以下操作：</p>
<ul>
<li>eachCount() 计算每个组中的元素。</li>
<li>fold() 与 reduce() 对每个组分别执行 fold 与 reduce 操作，作为一个单独的集合并返回结果。</li>
<li>aggregate() 随后将给定操作应用于每个组中的所有元素并返回结果。 这是对 <code>Grouping</code> 执行任何操作的通用方法。当折叠或缩小不够时，可使用它来实现自定义操作。</li>
</ul>
</li>
</ul>
<h5 id="map-系列"><a href="#map-系列" class="headerlink" title="map 系列"></a>map 系列</h5><ul>
<li><p>**<code>map(transform: (T) -&gt; R)</code>**：集合变换，遍历每个元素并执行给定表达式，最终形成新的集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.map &#123; it.plus(<span class="string">&quot;-1&quot;</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[Java-<span class="number">1</span>, Kotlin-<span class="number">1</span>, C-<span class="number">1</span>, C++-<span class="number">1</span>, JavaScript-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>mapTo(destination: C, transform: (T) -&gt; R)</code>**：多个集合的元素转换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> strList2 = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">println(mutableListOf&lt;String&gt;().apply &#123;</span><br><span class="line">    strList.mapTo(<span class="keyword">this</span>) &#123; it.plus(<span class="string">&quot;-1&quot;</span>) &#125;</span><br><span class="line">    strList2.mapTo(<span class="keyword">this</span>) &#123; it.plus(<span class="string">&quot;-2&quot;</span>) &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[A-<span class="number">1</span>, B-<span class="number">1</span>, C-<span class="number">1</span>, a-<span class="number">2</span>, b-<span class="number">2</span>, c-<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>mapIndexed(transform: (index: Int, T) -&gt; R)</code>**：带有元素下标的集合转换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">println(strList.mapIndexed &#123; index, s -&gt; <span class="string">&quot;<span class="variable">$index</span>-<span class="variable">$s</span>&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">0</span>-A, <span class="number">1</span>-B, <span class="number">2</span>-C]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>mapIndexedTo(destination: C, transform: (index: Int, T) -&gt; R)</code>**：带有元素下标的多个集合转换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> strList2 = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">println(mutableListOf&lt;String&gt;().apply &#123;</span><br><span class="line">    strList.mapIndexedTo(<span class="keyword">this</span>) &#123; index, s -&gt; <span class="string">&quot;<span class="variable">$index</span>-<span class="variable">$s</span>&quot;</span> &#125;</span><br><span class="line">    strList2.mapIndexedTo(<span class="keyword">this</span>) &#123; index, s -&gt; <span class="string">&quot;<span class="variable">$index</span>-<span class="variable">$s</span>&quot;</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[<span class="number">0</span>-A, <span class="number">1</span>-B, <span class="number">2</span>-C, <span class="number">0</span>-a, <span class="number">1</span>-b, <span class="number">2</span>-c]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>mapNotNull(transform: (T) -&gt; R?)</code>**：同 <code>map</code> 函数的作用相同，不过其过滤了集合转换后为 null 的元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.mapNotNull &#123; <span class="keyword">if</span> (it.startsWith(<span class="string">&quot;Java&quot;</span>)) <span class="literal">null</span> <span class="keyword">else</span> it &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">[Kotlin, C, C++]</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>mapNotNullTo(destination: C, transform: (T) -&gt; R?)</code>**：同 mapNotNull 函数的作用相同，它适用于多集合操作场景。</p>
</li>
<li><p>**<code>mapIndexedNotNull</code> 和 <code>mapIndexedNotNullTo</code>**：同理。</p>
</li>
</ul>
<h4 id="元素类操作符"><a href="#元素类操作符" class="headerlink" title="元素类操作符"></a>元素类操作符</h4><h5 id="element-系列"><a href="#element-系列" class="headerlink" title="element 系列"></a>element 系列</h5><ul>
<li><p>**<code>elementAt(index: Int)</code>**：获取集合指定下标的元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.elementAt(<span class="number">1</span>)) <span class="comment">// 打印：Kotlin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>elementAtOrElse(index: Int, defaultValue: (Int) -&gt; T)</code>**：获取对应下标的集合元素。若下标越界，返回默认值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.elementAtOrElse(<span class="number">10</span>) &#123; <span class="string">&quot;unknown&quot;</span> &#125;) <span class="comment">// 打印：unknown</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>elementAtOrNull(index: Int)</code>**：获取对应下标的集合元素。若下标越界，返回 null。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.elementAtOrNull(<span class="number">10</span>)) <span class="comment">// 打印：null</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="first、last-系列"><a href="#first、last-系列" class="headerlink" title="first、last 系列"></a>first、last 系列</h5><ul>
<li><p>**<code>first()</code>**：获取集合第一个元素，若集合为空集合，这会抛出 NoSuchElementException 异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.first()) <span class="comment">// 打印：Java</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>first(predicate: (T) -&gt; Boolean)</code>**：获取集合中指定条件的第一个元素。若不满足条件，抛异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.first &#123; it.length &gt; <span class="number">5</span> &#125;) <span class="comment">// 打印：Kotlin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>firstOrNull()</code>**：获取集合第一个元素，若集合为空集合，返回 null。</p>
</li>
<li><p>**<code>firstOrNull&#123;&#125;</code>**：获取集合满足条件的首个元素，若无则返回 null。</p>
</li>
</ul>
<blockquote>
<p>与 <code>first</code> 等操作符对应的是 <code>last</code> 等相关操作符，即取集合最后一个元素等。</p>
</blockquote>
<h5 id="find-系列"><a href="#find-系列" class="headerlink" title="find 系列"></a>find 系列</h5><ul>
<li><p>**<code>find(predicate: (T) -&gt; Boolean)</code>**：获取集合满足条件的首个元素，若无则返回 null，其实就是 firstOrNull{}。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.find &#123; it.length &gt; <span class="number">5</span> &#125;) <span class="comment">// 打印：Kotlin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>findLast(predicate: (T) -&gt; Boolean)</code>**：获取集合满足条件的最后一个元素，若无则返回 null，其实就是 lastOrNull{}。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.findLast &#123; it.length &gt; <span class="number">5</span> &#125;) <span class="comment">// 打印：JavaScript</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="single-系列"><a href="#single-系列" class="headerlink" title="single 系列"></a>single 系列</h5><ul>
<li><p>**<code>single()</code>**：当集合中只有一个元素时，返回该元素，否则抛异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.single()) <span class="comment">// 打印：java.lang.IllegalArgumentException: List has more than one element.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>single(predicate: (T) -&gt; Boolean)</code>**：找到集合中满足条件的元素，若只有单个元素满足条件，则返回该元素，否则抛异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.single &#123; it.startsWith(<span class="string">&quot;K&quot;</span>) &#125;) <span class="comment">// 打印：Kotlin</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong><code>singleOrNull</code> 或 <code>singleOrNull&#123;&#125;</code> 操作符</strong> 只是将前述的抛异常改为返回 null。</p>
</blockquote>
<h5 id="component-系列"><a href="#component-系列" class="headerlink" title="component 系列"></a>component 系列</h5><ul>
<li><p>**<code>component1()</code> … <code>component5()</code>**：用于获取第 1 到第 5 个元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.component3()) <span class="comment">// 打印：C</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="indexOf-系列"><a href="#indexOf-系列" class="headerlink" title="indexOf 系列"></a>indexOf 系列</h5><ul>
<li><p>**<code>indexOf(element: T)</code>**：返回指定元素的下标，若不存在，则返回 -1。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.indexOf(<span class="string">&quot;C&quot;</span>)) <span class="comment">// 打印：2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>indexOfFirst(predicate: (T) -&gt; Boolean)</code>**：返回满足条件的第一个元素的下标，若不存在，则返回 -1。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.indexOfFirst &#123; it.length &gt; <span class="number">5</span> &#125;) <span class="comment">// 打印：1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>indexOfLast(predicate: (T) -&gt; Boolean)</code>**：返回满足条件的最后一个元素的下标，若不存在，则返回 -1。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.indexOfLast &#123; it.length &gt; <span class="number">5</span> &#125;) <span class="comment">// 打印：4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="排序类操作符"><a href="#排序类操作符" class="headerlink" title="排序类操作符"></a>排序类操作符</h4><h5 id="reverse-系列"><a href="#reverse-系列" class="headerlink" title="reverse 系列"></a>reverse 系列</h5><ul>
<li><p>**<code>reversed()</code>**：反转集合元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.reversed()) <span class="comment">// 打印：[JavaScript, C++, C, Kotlin, Java]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="sort-系列"><a href="#sort-系列" class="headerlink" title="sort 系列"></a>sort 系列</h5><ul>
<li><p>**<code>sorted()</code>**：对集合中的元素自然升序排序。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.sorted()) <span class="comment">// 打印：[C, C++, Java, JavaScript, Kotlin]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>sortedDescending()</code>**：与 sorted 操作符相反，为倒序。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.sortedDescending()) <span class="comment">// 打印：[Kotlin, JavaScript, Java, C++, C]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>sortedBy(crossinline selector: (T) -&gt; R?)</code>**：根据条件升序，即把不满足条件的放在前面，满足条件的放在后面。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.sortedBy &#123; it.length &#125;) <span class="comment">// 打印：[C, C++, Java, Kotlin, JavaScript]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>sortedByDescending(crossinline selector: (T) -&gt; R?)</code>**：与 sortedBy 操作符相反，为倒序。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.sortedByDescending &#123; it.length &#125;) <span class="comment">// 打印：[JavaScript, Kotlin, Java, C++, C]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="生成类操作符"><a href="#生成类操作符" class="headerlink" title="生成类操作符"></a>生成类操作符</h4><h5 id="partition-系列"><a href="#partition-系列" class="headerlink" title="partition 系列"></a>partition 系列</h5><ul>
<li><p>**<code>partition(predicate: (T) -&gt; Boolean)</code>**：将一个集合按条件拆分为两个 pair 组成的新集合。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.partition &#123; it.startsWith(<span class="string">&quot;Java&quot;</span>) &#125;) <span class="comment">// 打印：([Java, JavaScript], [Kotlin, C, C++])</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="plus-系列"><a href="#plus-系列" class="headerlink" title="plus 系列"></a>plus 系列</h5><ul>
<li><p>**<code>plus(element: T)</code>**：合并两个集合中的元素，组成一个新的集合。也可以使用符号 <code>+</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.plus(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))) <span class="comment">// 打印：[Java, Kotlin, C, C++, JavaScript, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>plusElement(element: T)</code>**：往集合中添加一个元素。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.plusElement(<span class="string">&quot;CSS&quot;</span>)) <span class="comment">// 打印：[Java, Kotlin, C, C++, JavaScript, CSS]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="zip-系列"><a href="#zip-系列" class="headerlink" title="zip 系列"></a>zip 系列</h5><ul>
<li><p>**<code>zip(other: Array&lt;out R&gt;)</code>**：由两个集合按照相同的下标组成一个新集合。该新集合的类型是：<code>List&lt;Pair&gt;</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.zip(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))) <span class="comment">// 打印：[(Java, 1), (Kotlin, 2), (C, 3)]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>zipWithNext(transform: (a: T, b: T) -&gt; R)</code>**：集合中相邻元素组成 <code>pairs</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strList = listOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>)</span><br><span class="line">println(strList.zipWithNext()) <span class="comment">// 打印：[(Java, Kotlin), (Kotlin, C), (C, C++), (C++, JavaScript)]</span></span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>明年今日
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://zhich.github.io/2023/04/26/Kotlin-%E6%95%99%E7%A8%8B/" title="Kotlin 教程">https://zhich.github.io/2023/04/26/Kotlin-教程/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
              <a href="/tags/Kotlin/" rel="tag"><i class="fa fa-tag"></i> Kotlin</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/30/Dart-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Dart 学习笔记">
                  <i class="fa fa-angle-left"></i> Dart 学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/08/Kotlin-%E5%8D%8F%E7%A8%8B/" rel="next" title="Kotlin 协程">
                  Kotlin 协程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Copyright © 明年今日。 All Rights Reserved.</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poaWNo" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://zhich.github.io/2023/04/26/Kotlin-%E6%95%99%E7%A8%8B/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
