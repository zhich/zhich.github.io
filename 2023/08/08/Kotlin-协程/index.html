<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="uhuV0rnYMUWuzeZrPSHxh_QSZ6tM5AWsUD-fXyEVOOc">
  <meta name="baidu-site-verification" content="codeva-jBfPQBw271">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-mac-osx.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhich.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":true,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"giscus","storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="协程是什么协程基于线程，它是轻量级线程。  协程让异步逻辑同步化，杜绝回调地狱。 协程最核心的点就是，函数或者一段程序能够被挂起，稍后再在挂起的位置恢复。  在 Android 中协程用来解决什么问题 处理耗时任务，这种任务常常会阻塞主线程。 保证主线程安全，即安全地从主线程调用任务 suspend 函数。  协程的挂起和恢复常规函数基础操作包括：invoke（或 call）和 ret">
<meta property="og:type" content="blog">
<meta property="og:title" content="Kotlin 协程">
<meta property="og:url" content="https://zhich.github.io/2023/08/08/Kotlin-%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="明年今日">
<meta property="og:description" content="协程是什么协程基于线程，它是轻量级线程。  协程让异步逻辑同步化，杜绝回调地狱。 协程最核心的点就是，函数或者一段程序能够被挂起，稍后再在挂起的位置恢复。  在 Android 中协程用来解决什么问题 处理耗时任务，这种任务常常会阻塞主线程。 保证主线程安全，即安全地从主线程调用任务 suspend 函数。  协程的挂起和恢复常规函数基础操作包括：invoke（或 call）和 ret">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/zch0304/images/raw/master/note/676350c3f83e92cda2f87c2b90471451.png">
<meta property="og:image" content="https://gitee.com/zch0304/images/raw/master/note/1663391441985.png">
<meta property="og:image" content="https://gitee.com/zch0304/images/raw/master/note/1663680667795.jpg">
<meta property="og:image" content="https://gitee.com/zch0304/images/raw/master/note/1666439476014.jpg">
<meta property="og:image" content="https://gitee.com/zch0304/images/raw/master/note/1666502596729.jpg">
<meta property="og:image" content="https://gitee.com/zch0304/images/raw/master/note/1666531343879.png">
<meta property="article:published_time" content="2023-08-08T14:25:00.000Z">
<meta property="article:modified_time" content="2024-06-03T14:53:51.435Z">
<meta property="article:author" content="明年今日">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Kotlin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/zch0304/images/raw/master/note/676350c3f83e92cda2f87c2b90471451.png">


<link rel="canonical" href="https://zhich.github.io/2023/08/08/Kotlin-%E5%8D%8F%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhich.github.io/2023/08/08/Kotlin-%E5%8D%8F%E7%A8%8B/","path":"2023/08/08/Kotlin-协程/","title":"Kotlin 协程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Kotlin 协程 | 明年今日</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">明年今日</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-globe fa-fw fa-fw"></i>links</a></li><li class="menu-item menu-item-happy"><a href="/happy/" rel="section"><i class="fa fa-th fa-fw"></i>happy</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">协程是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Android-%E4%B8%AD%E5%8D%8F%E7%A8%8B%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">在 Android 中协程用来解决什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">3.</span> <span class="nav-text">协程的挂起和恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E4%B8%8E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">挂起与阻塞的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">挂起函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%A4%E9%83%A8%E5%88%86"><span class="nav-number">6.</span> <span class="nav-text">协程的两部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%B3%84%E6%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">任务泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="nav-number">9.</span> <span class="nav-text">结构化并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoroutineScope"><span class="nav-number">10.</span> <span class="nav-text">CoroutineScope</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MainScope-%E4%BD%BF%E7%94%A8"><span class="nav-number">11.</span> <span class="nav-text">MainScope 使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text">协程构建器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-%E5%92%8C-await-%E7%AD%89%E5%BE%85%E5%8D%8F%E7%A8%8B%E4%BD%9C%E4%B8%9A"><span class="nav-number">13.</span> <span class="nav-text">join 和 await 等待协程作业</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-%E7%BB%84%E5%90%88%E5%B9%B6%E5%8F%91"><span class="nav-number">14.</span> <span class="nav-text">async 组合并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">协程的启动模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="nav-number">16.</span> <span class="nav-text">协程的作用域构建器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#coroutineScope-%E4%B8%8E-runBlocking"><span class="nav-number">16.1.</span> <span class="nav-text">coroutineScope 与 runBlocking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#coroutineScope-%E4%B8%8E-supervisorScope"><span class="nav-number">16.2.</span> <span class="nav-text">coroutineScope 与 supervisorScope</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Job-%E5%AF%B9%E8%B1%A1"><span class="nav-number">17.</span> <span class="nav-text">Job 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Job-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">18.</span> <span class="nav-text">Job 的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88"><span class="nav-number">19.</span> <span class="nav-text">协程的取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88"><span class="nav-number">20.</span> <span class="nav-text">CPU 密集型任务取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%8F%96%E6%B6%88%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">21.</span> <span class="nav-text">协程取消的副作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E5%8F%96%E6%B6%88%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">22.</span> <span class="nav-text">不能取消的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">23.</span> <span class="nav-text">超时任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">24.</span> <span class="nav-text">协程的上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">24.1.</span> <span class="nav-text">组合上下文中的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">24.2.</span> <span class="nav-text">协程上下文的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%85%AC%E5%BC%8F"><span class="nav-number">24.3.</span> <span class="nav-text">协程上下文的公式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">25.</span> <span class="nav-text">协程的异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-number">25.1.</span> <span class="nav-text">异常处理的必要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="nav-number">25.2.</span> <span class="nav-text">异常的传播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%A0%B9%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">25.3.</span> <span class="nav-text">非根协程的异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7"><span class="nav-number">25.4.</span> <span class="nav-text">异常的传播特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SupervisorJob"><span class="nav-number">25.5.</span> <span class="nav-text">SupervisorJob</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#supervisorScope"><span class="nav-number">25.6.</span> <span class="nav-text">supervisorScope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7"><span class="nav-number">25.7.</span> <span class="nav-text">异常的捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android-%E4%B8%AD%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">25.8.</span> <span class="nav-text">Android 中全局异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="nav-number">25.9.</span> <span class="nav-text">取消与异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E8%81%9A%E5%90%88"><span class="nav-number">25.10.</span> <span class="nav-text">异常聚合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow"><span class="nav-number">26.</span> <span class="nav-text">Flow</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">26.1.</span> <span class="nav-text">异步返回多个值的方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flow-%E4%B8%8E%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.2.</span> <span class="nav-text">Flow 与其它方式的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B7%E6%B5%81"><span class="nav-number">26.3.</span> <span class="nav-text">冷流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7"><span class="nav-number">26.4.</span> <span class="nav-text">流的连续性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="nav-number">26.5.</span> <span class="nav-text">流构建器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">26.6.</span> <span class="nav-text">流上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E5%8D%8F%E7%A8%8B%E4%B8%AD%E6%94%B6%E9%9B%86%E6%B5%81"><span class="nav-number">26.7.</span> <span class="nav-text">在指定协程中收集流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E5%8F%96%E6%B6%88"><span class="nav-number">26.8.</span> <span class="nav-text">流的取消</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E5%8F%96%E6%B6%88%E6%A3%80%E6%B5%8B"><span class="nav-number">26.9.</span> <span class="nav-text">流的取消检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E5%8E%8B"><span class="nav-number">26.10.</span> <span class="nav-text">背压</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">26.11.</span> <span class="nav-text">操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">26.11.1.</span> <span class="nav-text">转换操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%90%E9%95%BF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">26.11.2.</span> <span class="nav-text">限长操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AB%E7%AB%AF%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">26.11.3.</span> <span class="nav-text">末端流操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">26.11.4.</span> <span class="nav-text">组合操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%95%E5%B9%B3%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">26.11.5.</span> <span class="nav-text">展平操作符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">26.12.</span> <span class="nav-text">流的异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E5%AE%8C%E6%88%90"><span class="nav-number">26.13.</span> <span class="nav-text">流的完成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel"><span class="nav-number">27.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Channel"><span class="nav-number">27.1.</span> <span class="nav-text">什么是 Channel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel-%E7%9A%84%E5%AE%B9%E9%87%8F"><span class="nav-number">27.2.</span> <span class="nav-text">Channel 的容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3-Channel"><span class="nav-number">27.3.</span> <span class="nav-text">迭代 Channel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#produce-%E4%B8%8E-actor"><span class="nav-number">27.4.</span> <span class="nav-text">produce 与 actor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel-%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-number">27.5.</span> <span class="nav-text">Channel 的关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BroadcastChannel"><span class="nav-number">27.6.</span> <span class="nav-text">BroadcastChannel</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">28.</span> <span class="nav-text">select - 多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">28.1.</span> <span class="nav-text">什么是多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8%E5%A4%9A%E4%B8%AA-await"><span class="nav-number">28.2.</span> <span class="nav-text">复用多个 await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8%E5%A4%9A%E4%B8%AA-Channel"><span class="nav-number">28.3.</span> <span class="nav-text">复用多个 Channel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SelectClause"><span class="nav-number">28.4.</span> <span class="nav-text">SelectClause</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Flow-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">28.5.</span> <span class="nav-text">使用 Flow 实现多路复用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="nav-number">29.</span> <span class="nav-text">并发安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE"><span class="nav-number">29.1.</span> <span class="nav-text">不安全的并发访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-number">29.2.</span> <span class="nav-text">协程的并发工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81"><span class="nav-number">29.3.</span> <span class="nav-text">避免访问外部可变状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B7%E6%B5%81%E8%BF%98%E6%98%AF%E7%83%AD%E6%B5%81"><span class="nav-number">30.</span> <span class="nav-text">冷流还是热流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StateFlow"><span class="nav-number">31.</span> <span class="nav-text">StateFlow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SharedFlow"><span class="nav-number">32.</span> <span class="nav-text">SharedFlow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flow-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">33.</span> <span class="nav-text">Flow 的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Flow-%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">33.1.</span> <span class="nav-text">Flow 与文件下载的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flow-%E4%B8%8E-Room-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">33.2.</span> <span class="nav-text">Flow 与 Room 的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flow-%E4%B8%8E-Retrofit-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">33.3.</span> <span class="nav-text">Flow 与 Retrofit 的应用</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="明年今日"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">明年今日</p>
  <div class="site-description" itemprop="description">终身学习者。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poaWNo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhich"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnpoaWNoMTEyMTM0QGdtYWlsLmNvbQ==" title="E-Mail → mailto:zhich112134@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhich.github.io/2023/08/08/Kotlin-%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="明年今日">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="明年今日">
      <meta itemprop="description" content="终身学习者。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Kotlin 协程 | 明年今日">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kotlin 协程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-08 22:25:00" itemprop="dateCreated datePublished" datetime="2023-08-08T22:25:00+08:00">2023-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-03 22:53:51" itemprop="dateModified" datetime="2024-06-03T22:53:51+08:00">2024-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><meta name="referrer" content="no-referrer" />





<h3 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h3><p>协程基于线程，它是轻量级线程。</p>
<ul>
<li>协程让<strong>异步逻辑同步化</strong>，杜绝回调地狱。</li>
<li>协程最核心的点就是，函数或者一段程序能够被<strong>挂起</strong>，稍后再在挂起的位置<strong>恢复</strong>。</li>
</ul>
<h3 id="在-Android-中协程用来解决什么问题"><a href="#在-Android-中协程用来解决什么问题" class="headerlink" title="在 Android 中协程用来解决什么问题"></a>在 Android 中协程用来解决什么问题</h3><ul>
<li><strong>处理耗时任务</strong>，这种任务常常会阻塞主线程。</li>
<li><strong>保证主线程安全</strong>，即安全地从主线程调用任务 suspend 函数。</li>
</ul>
<h3 id="协程的挂起和恢复"><a href="#协程的挂起和恢复" class="headerlink" title="协程的挂起和恢复"></a>协程的挂起和恢复</h3><p>常规函数基础操作包括：invoke（或 call）和 return，协程增加了 suspend 和 resume。</p>
<ul>
<li>suspend：也称为挂起或暂停，用于暂停执行当前协程，并保存所有局部变量。</li>
<li>resume：用于让已暂停的协程从其暂停处继续执行。</li>
</ul>
<h3 id="挂起与阻塞的区别"><a href="#挂起与阻塞的区别" class="headerlink" title="挂起与阻塞的区别"></a>挂起与阻塞的区别</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    delay(<span class="number">5000</span>)</span><br><span class="line">    Log.d(<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>:after delay.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞</span></span><br><span class="line">Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">Log.d(<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>:after sleep.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><ul>
<li>使用 suspend 关键字修饰的函数叫做挂起函数。</li>
<li>挂起函数只能在<strong>协程体内</strong>或<strong>其它挂起函数内</strong>调用。</li>
</ul>
<h3 id="协程的两部分"><a href="#协程的两部分" class="headerlink" title="协程的两部分"></a>协程的两部分</h3><p>Kotlin 的协程实现分为两个层次：</p>
<ul>
<li>基础设施层，标准库的协程 API，主要对协程提供了概念和语义上最基本的支持。</li>
<li>业务框架层，协程的上层框架支持。</li>
</ul>
<p>基础设施层的一个 demo：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程体</span></span><br><span class="line"><span class="keyword">val</span> continuation = <span class="keyword">suspend</span> &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Coroutine End: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">continuation.resume(<span class="built_in">Unit</span>)</span><br></pre></td></tr></table></figure>

<p>基础设施层使用的是 <code>kotlin.coroutines.*</code> 而业务框架层使用的是 <code>kotlinx.coroutines.*</code>。</p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>所有协程必须在调度器中运行，即使它们在主线程上运行也是如此。</p>
<ul>
<li><p><strong>Dispatchers.Main</strong>。Android 上的主线程，用来处理 UI 交互和一些轻量级任务（调用 suspend 函数；调用 UI 函数；更新 LiveData）。</p>
</li>
<li><p><strong>Dispatchers.IO</strong>。非主线程，专为磁盘和网络 IO 进行了优化（数据库；文件读写；网络处理）。</p>
</li>
<li><p><strong>Dispatchers.Default</strong>。非主线程，专为 CPU 密集型任务进行了优化（数组排序；JSON 数据解析；处理差异判断）。</p>
</li>
</ul>
<h3 id="任务泄漏"><a href="#任务泄漏" class="headerlink" title="任务泄漏"></a>任务泄漏</h3><ul>
<li>当某个协程任务丢失，无法追踪，会导致内存、CPU、磁盘等资源浪费，甚至发送一个无用的网络请求，这种情况称为任务泄漏。</li>
<li>为了能够避免协程泄漏，Kotlin 引入了结构化并发机制。</li>
</ul>
<h3 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h3><p>使用结构化并发可以做到：</p>
<ul>
<li>取消任务，当某项任务不再需要时，取消它。</li>
<li>追踪任务，当任务正在执行时，追踪它。</li>
<li>发出错误信号，当协程失败时，发出错误信号表明有错误发生。</li>
</ul>
<h3 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h3><p>1、定义协程必须指定其 CoroutineScope，它会跟踪所有协程，同样它还可以<strong>取消由它所启动的所有协程</strong>。</p>
<p>2、常用的相关 API 有：</p>
<ul>
<li><strong>GlobalScope</strong>，生命周期是 process 级别的，即使 Activity 或 Fragment 已经被销毁，协程仍然在执行。</li>
<li><strong>MainScope</strong>，在 Activity 中使用，可以在 onDestroy() 中取消协程。</li>
<li><strong>viewModelScope</strong>，只能在 ViewModel 中使用，绑定 ViewModel 生命周期。</li>
<li><strong>lifecycleScope</strong>，只能在 Activity、Fragment 中使用，会绑定 Activity 和 Fragment 的生命周期。</li>
</ul>
<h3 id="MainScope-使用"><a href="#MainScope-使用" class="headerlink" title="MainScope 使用"></a>MainScope 使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CoroutineActivity</span> : <span class="type">AppCompatActivity</span>(), CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_coroutine)</span><br><span class="line"></span><br><span class="line">        submit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">submit</span><span class="params">()</span></span> &#123;</span><br><span class="line">        btnSubmit?.setOnClickListener &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    delay(<span class="number">5000</span>)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 取消协程会抛出异常</span></span><br><span class="line"><span class="comment">                     * kotlinx.coroutines.JobCancellationException: Job was cancelled; job=SupervisorJobImpl&#123;Cancelling&#125;@7e7375b</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cancel()</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协程构建器"><a href="#协程构建器" class="headerlink" title="协程构建器"></a>协程构建器</h3><p>launch 和 async 构建器都可以用来启动新协程：</p>
<ul>
<li><strong>launch</strong>，返回一个 Job 并且不附带任何结果值。</li>
<li><strong>async</strong>，返回一个 Deferred，Deferred 也是一个 Job，可以使用 .await() 在一个延期的值上得到它的最终结果。</li>
</ul>
<p>等待一个作业：</p>
<ul>
<li>join 和 await。</li>
<li>组合并发。</li>
</ul>
<p>测试构建器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `coroutine builder`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        println(<span class="string">&quot;job1 finished.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job2 = async &#123;</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        println(<span class="string">&quot;job2 finished.&quot;</span>)</span><br><span class="line">        <span class="string">&quot;job2 result&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(job2.await())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job1 finished.</span><br><span class="line">job2 finished.</span><br><span class="line">job2 result</span><br></pre></td></tr></table></figure>

<blockquote>
<p>runBlocking 把当前线程包装成一个协程，它会阻塞当前线程等待子协程执行完再结束。</p>
</blockquote>
<h3 id="join-和-await-等待协程作业"><a href="#join-和-await-等待协程作业" class="headerlink" title="join 和 await 等待协程作业"></a>join 和 await 等待协程作业</h3><p>测试 join：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `coroutine join`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">        println(<span class="string">&quot;One&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job1.join()</span><br><span class="line">    <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        println(<span class="string">&quot;Two&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        println(<span class="string">&quot;Three&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br></pre></td></tr></table></figure>

<p>测试 await：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `coroutine await`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = async &#123;</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">        println(<span class="string">&quot;One&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job1.await()</span><br><span class="line">    <span class="keyword">val</span> job2 = async &#123;</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        println(<span class="string">&quot;Two&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job3 = async &#123;</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        println(<span class="string">&quot;Three&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br></pre></td></tr></table></figure>

<h3 id="async-组合并发"><a href="#async-组合并发" class="headerlink" title="async 组合并发"></a>async 组合并发</h3><p>测试同步 sync：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `coroutine sync`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = doOne()</span><br><span class="line">        <span class="keyword">val</span> two = doTwo()</span><br><span class="line">        println(<span class="string">&quot;The result:<span class="subst">$&#123;one + two&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">The result:<span class="number">2</span></span><br><span class="line">Completed <span class="keyword">in</span> <span class="number">2018</span> ms</span><br></pre></td></tr></table></figure>

<p>测试异步 async：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `coroutine async`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async &#123;</span><br><span class="line">            doOne()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async &#123;</span><br><span class="line">            doTwo()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;The result:<span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 以下形式，结果是 2m。</span></span><br><span class="line"><span class="comment">        val one = async &#123;</span></span><br><span class="line"><span class="comment">            doOne()</span></span><br><span class="line"><span class="comment">        &#125;.await()</span></span><br><span class="line"><span class="comment">        val two = async &#123;</span></span><br><span class="line"><span class="comment">            doTwo()</span></span><br><span class="line"><span class="comment">        &#125;.await()</span></span><br><span class="line"><span class="comment">        println(&quot;The result:$&#123;one + two&#125;&quot;)*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">The result:<span class="number">2</span></span><br><span class="line">Completed <span class="keyword">in</span> <span class="number">1034</span> ms</span><br></pre></td></tr></table></figure>

<h3 id="协程的启动模式"><a href="#协程的启动模式" class="headerlink" title="协程的启动模式"></a>协程的启动模式</h3><ul>
<li><p><strong>DEFAULT</strong>：协程创建后，立即开始调度，在调度前如果协程被取消，其将直接进入取消响应的状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `start mode DEFAULT`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.DEFAULT) &#123;</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;Job finished.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 什么也不打印</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ATOMIC</strong>：协程创建后，立即开始调度，协程执行到第一个挂起点之前不响应取消。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `start mode ATOMIC`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(start = CoroutineStart.ATOMIC) &#123;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">2100000000</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    count++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Before delay <span class="variable">$time</span> ms. count=<span class="variable">$count</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        println(<span class="string">&quot;Job finished.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    job.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Before delay <span class="number">1513</span> ms, count=<span class="number">1050000000.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LAZY</strong>：只有协程被需要时，包括主动调用协程的 start、join 或者 await 等函数时才会开始调度，如果调度前就被取消，那么该协程将直接进入异常结束状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `start mode LAZY`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = async (start = CoroutineStart.LAZY) &#123;</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">        println(<span class="string">&quot;Job finished.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调度前就取消，会抛出异常 kotlinx.coroutines.JobCancellationException</span></span><br><span class="line">    job.cancel()</span><br><span class="line">    job.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UNDISPATCHED</strong>：协程创建后立即在<strong>当前函数调用栈</strong>中执行，直到遇到第一个真正挂起的点。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `start mode UNDISPATCHED`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = async(context = Dispatchers.IO, start = CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">        println(<span class="string">&quot;thread1: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;thread2: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">thread1: Test worker <span class="meta">@coroutine</span>#<span class="number">2</span></span><br><span class="line">thread2: DefaultDispatcher-worker-<span class="number">1</span> <span class="meta">@coroutine</span>#<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="协程的作用域构建器"><a href="#协程的作用域构建器" class="headerlink" title="协程的作用域构建器"></a>协程的作用域构建器</h3><h4 id="coroutineScope-与-runBlocking"><a href="#coroutineScope-与-runBlocking" class="headerlink" title="coroutineScope 与 runBlocking"></a>coroutineScope 与 runBlocking</h4><ul>
<li>runBlocking 是常规函数，而 coroutineScope 是挂起函数。</li>
<li>它们都会等待其协程体结束，主要区别在于 runBlocking 会阻塞当前线程来等待，而 coroutineScope 只是挂起，会释放底层线程用于其它用途。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `coroutine coroutineScope builder`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            delay(<span class="number">400</span>)</span><br><span class="line">            println(<span class="string">&quot;job1 finished.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> job2 = async &#123;</span><br><span class="line">            delay(<span class="number">200</span>)</span><br><span class="line">            println(<span class="string">&quot;job2 finished.&quot;</span>)</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job2 finished.</span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException...</span><br></pre></td></tr></table></figure>

<h4 id="coroutineScope-与-supervisorScope"><a href="#coroutineScope-与-supervisorScope" class="headerlink" title="coroutineScope 与 supervisorScope"></a>coroutineScope 与 supervisorScope</h4><ul>
<li>coroutineScope：一个协程失败了，所有其它兄弟协程也会被取消。</li>
<li>supervisorScope：一个协程失败了，不会影响其它兄弟协程。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `coroutine supervisorScope builder`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            delay(<span class="number">400</span>)</span><br><span class="line">            println(<span class="string">&quot;job1 finished.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> job2 = async &#123;</span><br><span class="line">            delay(<span class="number">200</span>)</span><br><span class="line">            println(<span class="string">&quot;job2 finished.&quot;</span>)</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job2 finished.</span><br><span class="line">job1 finished.</span><br></pre></td></tr></table></figure>

<h3 id="Job-对象"><a href="#Job-对象" class="headerlink" title="Job 对象"></a>Job 对象</h3><ul>
<li>对于每一个创建的协程（通过 launch 或者 async），会返回一个 Job 实例，该实例是协程的唯一标示，并且负责管理协程的生命周期。</li>
<li>一个任务可以包含一系列状态：新创建（<strong>New</strong>）、活跃（<strong>Active</strong>）、完成中（<strong>Completing</strong>）、已完成（<strong>Completed</strong>）、取消中（<strong>Cancelling</strong>）和已取消（<strong>Cancelled</strong>）。虽然我们无法直接访问这些状态，但是我们可以访问 Job 的属性：isActive、isCancelled 和 isCompleted。</li>
</ul>
<h3 id="Job-的生命周期"><a href="#Job-的生命周期" class="headerlink" title="Job 的生命周期"></a>Job 的生命周期</h3><p>如果协程处于活跃状态，协程运行出错或者调用 job.cancel() 都会将当前任务置为取消中（Cancelling）状态（isActive &#x3D; false，isCancelled &#x3D; true）。当所有的子协程都完成后，协程会进入已取消（Cancelled）状态，此时 isCompleted &#x3D; true。</p>
<p><img data-src="https://gitee.com/zch0304/images/raw/master/note/676350c3f83e92cda2f87c2b90471451.png"> </p>
<h3 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h3><ul>
<li><p>取消作用域会取消它的子协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `scope cancel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Default)</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;job1.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;job2.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    scope.cancel()</span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无打印结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>被取消的子协程不会影响其余兄弟协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `brother cancel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Default)</span><br><span class="line">    <span class="keyword">val</span> job1 = scope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;job1.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job2 = scope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;job2.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    job1.cancel()</span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job2.</span><br></pre></td></tr></table></figure>
</li>
<li><p>协程通过抛出一个特殊的异常 CancellationException 来处理取消操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `CancellationException`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;job1.&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">/* job1.cancel(CancellationException(&quot;取消&quot;))</span></span><br><span class="line"><span class="comment">     job1.join()*/</span></span><br><span class="line">    job1.cancelAndJoin()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有 kotlinx.coroutines 中的挂起函数（withContext, delay 等）都是可取消的。</p>
</li>
</ul>
<h3 id="CPU-密集型任务取消"><a href="#CPU-密集型任务取消" class="headerlink" title="CPU 密集型任务取消"></a>CPU 密集型任务取消</h3><ul>
<li><p>isActive 是一个可以被使用在 CoroutineScope 中的扩展属性，检查 Job 是否处于活跃状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `cancel cpu task <span class="keyword">by</span> isActive`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span> &amp;&amp; isActive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job: I<span class="string">&#x27;m sleeping 0 ...</span></span><br><span class="line"><span class="string">job: I&#x27;</span>m sleeping <span class="number">1</span> ...</span><br><span class="line">job: I<span class="string">&#x27;m sleeping 2 ...</span></span><br><span class="line"><span class="string">main: I&#x27;</span>m tired of waiting!</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure>
</li>
<li><p>ensureActive()，如果 Job 处于非活跃状态，这个方法会抛出异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `cancel cpu task <span class="keyword">by</span> ensureActive`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            ensureActive() <span class="comment">// 抛出 CancellationException 异常，但被静默处理掉了。</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job: I<span class="string">&#x27;m sleeping 0 ...</span></span><br><span class="line"><span class="string">job: I&#x27;</span>m sleeping <span class="number">1</span> ...</span><br><span class="line">job: I<span class="string">&#x27;m sleeping 2 ...</span></span><br><span class="line"><span class="string">main: I&#x27;</span>m tired of waiting!</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure>
</li>
<li><p>yield 函数会检查所在协程的状态，如果已经取消，则抛出 CancellationException 予以响应。此外，它还会尝试出让线程的执行权，给其它协程提供执行机会。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `cancel cpu task <span class="keyword">by</span> yield`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            yield()</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job: I<span class="string">&#x27;m sleeping 0 ...</span></span><br><span class="line"><span class="string">job: I&#x27;</span>m sleeping <span class="number">1</span> ...</span><br><span class="line">job: I<span class="string">&#x27;m sleeping 2 ...</span></span><br><span class="line"><span class="string">main: I&#x27;</span>m tired of waiting!</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="协程取消的副作用"><a href="#协程取消的副作用" class="headerlink" title="协程取消的副作用"></a>协程取消的副作用</h3><ul>
<li><p>在 finally 中释放资源。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `release resources`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m running finally.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job: I<span class="string">&#x27;m sleeping 0 ...</span></span><br><span class="line"><span class="string">job: I&#x27;</span>m sleeping <span class="number">1</span> ...</span><br><span class="line">job: I<span class="string">&#x27;m sleeping 2 ...</span></span><br><span class="line"><span class="string">main: I&#x27;</span>m tired of waiting!</span><br><span class="line">job: I<span class="string">&#x27;m running finally.</span></span><br><span class="line"><span class="string">main: Now I can quit.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>use 函数：该函数只能被实现了 Closeable 的对象使用，程序结束的时候会自动调用 close 方法，适合文件对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `use function`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">/*val br = BufferedReader(FileReader(&quot;E:\\Hello.txt&quot;))</span></span><br><span class="line"><span class="comment">    var line: String?</span></span><br><span class="line"><span class="comment">    try &#123;</span></span><br><span class="line"><span class="comment">        while (true) &#123;</span></span><br><span class="line"><span class="comment">            line = br.readLine() ?: break</span></span><br><span class="line"><span class="comment">            println(line)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; catch (e: Exception) &#123;</span></span><br><span class="line"><span class="comment">    &#125; finally &#123;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            br.close()</span></span><br><span class="line"><span class="comment">        &#125; catch (e: Exception) &#123;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    BufferedReader(FileReader(<span class="string">&quot;E:\\Hello.txt&quot;</span>)).use &#123;</span><br><span class="line">        <span class="keyword">var</span> line: String?</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            line = it.readLine() ?: <span class="keyword">break</span></span><br><span class="line">            println(line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="不能取消的任务"><a href="#不能取消的任务" class="headerlink" title="不能取消的任务"></a>不能取消的任务</h3><p>处于取消中状态的协程不能够挂起（运行不能取消的代码），当协程被取消后需要调用挂起函数，我们需要将清理任务的代码放置于 NonCancellable CoroutineContext 中。这样会挂起运行中的代码，并保持协程取消中状态直到任务处理完成。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `cancel with NonCancelable`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m running finally.&quot;</span>)</span><br><span class="line">                delay(<span class="number">1000</span>)</span><br><span class="line">                println(<span class="string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job: I<span class="string">&#x27;m sleeping 0 ...</span></span><br><span class="line"><span class="string">job: I&#x27;</span>m sleeping <span class="number">1</span> ...</span><br><span class="line">job: I<span class="string">&#x27;m sleeping 2 ...</span></span><br><span class="line"><span class="string">main: I&#x27;</span>m tired of waiting!</span><br><span class="line">job: I<span class="string">&#x27;m running finally.</span></span><br><span class="line"><span class="string">job: And I&#x27;</span>ve just delayed <span class="keyword">for</span> <span class="number">1</span> sec because I<span class="string">&#x27;m non-cancellable.</span></span><br><span class="line"><span class="string">main: Now I can quit.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>NonCancellable 可用于常驻任务。</p>
</blockquote>
<h3 id="超时任务"><a href="#超时任务" class="headerlink" title="超时任务"></a>超时任务</h3><ul>
<li><p>很多情况下取消一个协程的理由是它有可能超时。用 withTimeout 进行超时操作，如果规定时间内未完成任务则会抛出异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `deal with withTimeout`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    withTimeout(<span class="number">1300</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job: I<span class="string">&#x27;m sleeping 0 ...</span></span><br><span class="line"><span class="string">job: I&#x27;</span>m sleeping <span class="number">1</span> ...</span><br><span class="line">job: I<span class="string">&#x27;m sleeping 2 ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Timed out waiting for 1300 ms</span></span><br><span class="line"><span class="string">kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>withTimeoutOrNull 通过返回 null 来进行超时操作，从而替代抛出一个异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `deal with withTimeoutOrNull`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;Done&quot;</span></span><br><span class="line">    &#125; ?: <span class="string">&quot;Undone&quot;</span></span><br><span class="line">    println(<span class="string">&quot;Result is <span class="variable">$result</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job: I<span class="string">&#x27;m sleeping 0 ...</span></span><br><span class="line"><span class="string">job: I&#x27;</span>m sleeping <span class="number">1</span> ...</span><br><span class="line">job: I<span class="string">&#x27;m sleeping 2 ...</span></span><br><span class="line"><span class="string">Result is Undone.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="协程的上下文"><a href="#协程的上下文" class="headerlink" title="协程的上下文"></a>协程的上下文</h3><p>CoroutineContext 是一组用于定义协程行为的元素，它由如下几项构成：</p>
<ul>
<li><strong>Job</strong>：控制协程的生命周期。</li>
<li><strong>CoroutineDispatcher</strong>：向合适的线程分发任务。</li>
<li><strong>CoroutineName</strong>：协程的名称，调试的时候很有用。</li>
<li><strong>CoroutineExceptionHandler</strong>：处理未被捕获的异常。</li>
</ul>
<h4 id="组合上下文中的元素"><a href="#组合上下文中的元素" class="headerlink" title="组合上下文中的元素"></a>组合上下文中的元素</h4><p>有时我们需要在协程上下文中定义多个元素，我们可以使用 “+” 操作符来实现。比如，我们可以显示指定一个调度器来启动协程并且同时显示指定一个命名：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `CoroutineContext`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Default + CoroutineName(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">        println(<span class="string">&quot;I&#x27;m working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">I<span class="string">&#x27;m working in thread DefaultDispatcher-worker-1 @hello#2</span></span><br></pre></td></tr></table></figure>

<h4 id="协程上下文的继承"><a href="#协程上下文的继承" class="headerlink" title="协程上下文的继承"></a>协程上下文的继承</h4><p>对于新创建的协程，它的 CoroutineContext 会包含一个全新的 Job 实例，它会帮助我们控制协程的生命周期。而<strong>剩下的元素会从 CoroutineContext 的父类继承</strong>，该父类可能是另外一个协程或者创建该协程的 CoroutineScope。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `CoroutineContext extend`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + Dispatchers.IO + CoroutineName(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> job = scope.launch &#123;</span><br><span class="line">        <span class="comment">// 新的协程会将 CoroutineScope 作为父级</span></span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;coroutineContext[Job]&#125;</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = async &#123;</span><br><span class="line">             <span class="comment">// 通过 async 创建的新协程会将当前协程作为父级</span></span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;coroutineContext[Job]&#125;</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="string">&quot;OK&quot;</span></span><br><span class="line">        &#125;.await()</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="string">&quot;hello#2&quot;</span>:StandaloneCoroutine&#123;Active&#125;@55b8c583 DefaultDispatcher-worker-<span class="number">1</span> <span class="meta">@hello</span>#<span class="number">2</span></span><br><span class="line"><span class="string">&quot;hello#3&quot;</span>:DeferredCoroutine&#123;Active&#125;@64e55ef0 DefaultDispatcher-worker-<span class="number">3</span> <span class="meta">@hello</span>#<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="协程上下文的公式"><a href="#协程上下文的公式" class="headerlink" title="协程上下文的公式"></a>协程上下文的公式</h4><p>协程上下文 &#x3D; <strong>默认值</strong> + <strong>继承的 CoroutineContext</strong> + <strong>参数</strong>。</p>
<ul>
<li>一些元素包含默认值：Dispatchers.Default 是默认的 CoroutineDispatcher，以及 “coroutine” 作为默认的 CoroutineName。</li>
<li>继承的 CoroutineContext 是 CoroutineScope 或者其父协程的 CoroutineContext。</li>
<li>传入协程构建器的参数的优先级高于继承的上下文，隐藏会覆盖对应参数值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `CoroutineContext extend2`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; _, excption -&gt;</span><br><span class="line">        println(<span class="string">&quot;CoroutineExceptionHandler got <span class="variable">$excption</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job() + Dispatchers.Main + coroutineExceptionHandler)</span><br><span class="line">    <span class="comment">// 新的 CoroutineContext = 父级 CoroutineContext + Job()</span></span><br><span class="line">    <span class="keyword">val</span> job = scope.launch(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="comment">// 新协程</span></span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;coroutineContext[Job]&#125;</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="string">&quot;coroutine#2&quot;</span>:StandaloneCoroutine&#123;Active&#125;@78ec7afa DefaultDispatcher-worker-<span class="number">1</span> <span class="meta">@coroutine</span>#<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="协程的异常处理"><a href="#协程的异常处理" class="headerlink" title="协程的异常处理"></a>协程的异常处理</h3><h4 id="异常处理的必要性"><a href="#异常处理的必要性" class="headerlink" title="异常处理的必要性"></a>异常处理的必要性</h4><p>当应用出现一些意外情况时，给用户提供合适的体验非常重要。一方面，目睹应用崩溃是个很糟糕的体验，另一方面，当用户操作失败时，也必须要能给出正确的提示信息。</p>
<h4 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h4><p>协程构建器有两种形式：<strong>自动传播异常</strong>（launch 与 actor），<strong>向用户暴露异常</strong>（async 与 produce）。当这些构建器用于创建一个<strong>根协程</strong>时（该协程不是另一个协程的子协程），前者这类构建器，异常会在它发生的第一时间被抛出，而后者则依赖用户来最终消费异常，例如通过 await 或 receive。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `exception propagation`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> IndexOutOfBoundsException()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            println(<span class="string">&quot;Caught IndexOutOfBoundsException&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deferred.await()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught ArithmeticException&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Caught IndexOutOfBoundsException</span><br><span class="line">Caught ArithmeticException</span><br></pre></td></tr></table></figure>

<h4 id="非根协程的异常"><a href="#非根协程的异常" class="headerlink" title="非根协程的异常"></a>非根协程的异常</h4><p>其它协程所创建的协程中，产生的异常总是会被传播。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `exception propagation2`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    <span class="keyword">val</span> job = scope.launch &#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            <span class="comment">// 如果 async 抛出异常，launch 就会立刻抛出异常，而不会调用 .await()</span></span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;DefaultDispatcher-worker-1 @coroutine#3&quot;</span> java.lang.IllegalArgumentException</span><br></pre></td></tr></table></figure>

<h4 id="异常的传播特性"><a href="#异常的传播特性" class="headerlink" title="异常的传播特性"></a>异常的传播特性</h4><p>当一个协程由于一个异常而运行失败时，它会传播这个异常并传递给它的父级。接下来，父级会进行下面几步操作：</p>
<ul>
<li>取消它的子级。</li>
<li>取消它自己。</li>
<li>将异常传播并传递给它的父级。</li>
</ul>
<h4 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a>SupervisorJob</h4><ul>
<li>使用 SupervisorJob 时，一个子协程的运行失败不会影响到其它子协程。SupervisorJob 不会传播异常给它的父级，它会<strong>让子协程自己处理异常</strong>。</li>
<li>这种需求常见于在作用域内定义作业的 UI 组件，如果任一个 UI 的子作业执行失败了，它并不总是有必要取消整个 UI 组件，但是如果 UI 组件被销毁了，由于它的结果不再被需要了，它就有必要使所有的子作业执行失败。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test SupervisorJob`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> supervisor = CoroutineScope(SupervisorJob())</span><br><span class="line">    <span class="keyword">val</span> job1 = supervisor.launch &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;child 1.&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job2 = supervisor.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="built_in">Long</span>.MAX_VALUE)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;child 2 finished.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        delay(200)</span></span><br><span class="line"><span class="comment">//        supervisor.cancel()</span></span><br><span class="line">    joinAll(job1, job2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">child <span class="number">1.</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;DefaultDispatcher-worker-2 @coroutine#2&quot;</span> java.lang.IllegalArgumentException</span><br><span class="line">一直运行中......</span><br></pre></td></tr></table></figure>

<h4 id="supervisorScope"><a href="#supervisorScope" class="headerlink" title="supervisorScope"></a>supervisorScope</h4><p>当作业自身执行失败的时候，所有子作业将会全部被取消。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test supervisorScope`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            println(<span class="string">&quot;child 1.&quot;</span>)</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            delay(<span class="built_in">Long</span>.MAX_VALUE)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;child 2 finished.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">child <span class="number">1.</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;Test worker @coroutine#2&quot;</span> java.lang.IllegalArgumentException</span><br><span class="line">一直运行中......</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test supervisorScope2`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;The child is sleeping.&quot;</span>)</span><br><span class="line">                delay(<span class="built_in">Long</span>.MAX_VALUE)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;The child is cancelled.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        yield()</span><br><span class="line">        println(<span class="string">&quot;Throwing an exception from the scope.&quot;</span>)</span><br><span class="line">        <span class="keyword">throw</span> AssertionError()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">The child <span class="keyword">is</span> sleeping.</span><br><span class="line">Throwing an exception from the scope.</span><br><span class="line">The child <span class="keyword">is</span> cancelled.</span><br><span class="line"></span><br><span class="line">java.lang.AssertionError</span><br></pre></td></tr></table></figure>

<h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><ul>
<li>使用 CoroutineExceptionHandler 对协程的异常进行捕获。</li>
<li>以下的条件被满足时，异常就会被捕获。<ul>
<li><strong>时机</strong>：异常是被自动抛出异常的协程所抛出的（使用 launch，而不是 async 时）。</li>
<li><strong>位置</strong>：在 CoroutineScope 的 CoroutineContext 中或在一个根协程（CoroutineScope 或者 supervisorScope 的直接子协程）中。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test coroutineExceptionHandler`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> handler = CoroutineExceptionHandler &#123; _, excption -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$excption</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(handler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> AssertionError()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> deferred = GlobalScope.async(handler) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    deferred.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Caught java.lang.AssertionError</span><br><span class="line"></span><br><span class="line">java.lang.ArithmeticException</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test coroutineExceptionHandler2`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> handler = CoroutineExceptionHandler &#123; _, excption -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$excption</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    <span class="keyword">val</span> job = scope.launch(handler) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Caught java.lang.ArithmeticException</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test coroutineExceptionHandler3`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> handler = CoroutineExceptionHandler &#123; _, excption -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$excption</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">    <span class="keyword">val</span> job = scope.launch &#123;</span><br><span class="line">        <span class="comment">// handler 放这里捕获不到异常</span></span><br><span class="line">        launch(handler) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;DefaultDispatcher-worker-1 @coroutine#3&quot;</span> java.lang.ArithmeticException</span><br></pre></td></tr></table></figure>

<h4 id="Android-中全局异常处理"><a href="#Android-中全局异常处理" class="headerlink" title="Android 中全局异常处理"></a>Android 中全局异常处理</h4><ul>
<li>全局异常处理器可以获取到所有协程未处理的未捕获异常，不过它并不能对异常进行捕获，虽然<strong>不能阻止程序崩溃</strong>，全局异常处理器在程序调试和异常上报等场景中仍然有非常大的用处。</li>
<li>我们需要在 classpath 下面创建 META-INF&#x2F;services 目录，并在其中创建一个名为 kotlinx.coroutines.CoroutineExceptionHandler 的文件，文件内容就是我们的全局异常处理器的全类名。</li>
</ul>
<p>正常情况捕获异常（程序不崩溃）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> handler = CoroutineExceptionHandler &#123; _, excption -&gt;</span><br><span class="line">    Log.d(<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;Caught <span class="variable">$excption</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btnGlobalCoroutineExceptionHandler?.setOnClickListener &#123;</span><br><span class="line">    GlobalScope.launch(handler) &#123;</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>.substring(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">D/tag: Caught java.lang.StringIndexOutOfBoundsException: length=<span class="number">3</span>; index=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>全局异常处理器获取未被捕获异常（程序崩溃）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">btnGlobalCoroutineExceptionHandler?.setOnClickListener &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>.substring(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">D/tag: Unhandled Coroutine Exception: java.lang.StringIndexOutOfBoundsException: length=<span class="number">3</span>; index=<span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    --------- beginning of crash</span><br><span class="line">E/AndroidRuntime: FATAL EXCEPTION: DefaultDispatcher-worker-<span class="number">1</span></span><br><span class="line">    Process: com.zch.kotlin, PID: <span class="number">3436</span></span><br><span class="line">    java.lang.StringIndexOutOfBoundsException: length=<span class="number">3</span>; index=<span class="number">10</span></span><br><span class="line">        at java.lang.String.substring(String.java:<span class="number">1899</span>)</span><br></pre></td></tr></table></figure>

<h4 id="取消与异常"><a href="#取消与异常" class="headerlink" title="取消与异常"></a>取消与异常</h4><ul>
<li>取消与异常紧密相关，协程内部使用 CancellationException 来进行取消，这个异常会被忽略。</li>
<li>当子协程被取消时，不会取消它的父协程。</li>
<li>如果一个协程遇到了 CancellationException 以外的异常，它将使用该异常取消它的父协程。当父协程的所有子协程都结束后，异常才会被父协程处理。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test cancel and exception`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">val</span> child = launch &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                delay(<span class="built_in">Long</span>.MAX_VALUE)</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;Child is cancelled.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        yield()</span><br><span class="line">        println(<span class="string">&quot;Cancelling child.&quot;</span>)</span><br><span class="line">        child.cancelAndJoin()</span><br><span class="line">        yield()</span><br><span class="line">        println(<span class="string">&quot;Parent is not cancelled.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Cancelling child.</span><br><span class="line">Child <span class="keyword">is</span> cancelled.</span><br><span class="line">Parent <span class="keyword">is</span> not cancelled.</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test cancel and exception2`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> handler = CoroutineExceptionHandler &#123; _, excption -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$excption</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(handler) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                delay(<span class="built_in">Long</span>.MAX_VALUE)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                withContext(NonCancellable) &#123;</span><br><span class="line">                    println(<span class="string">&quot;Children are cancelled, but exception is not handled until all children termination.&quot;</span>)</span><br><span class="line">                    delay(<span class="number">100</span>)</span><br><span class="line">                    println(<span class="string">&quot;The first child finished its non cancellable block.&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">10</span>)</span><br><span class="line">            println(<span class="string">&quot;Second child throws an exception.&quot;</span>)</span><br><span class="line">            <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Second child throws an exception.</span><br><span class="line">Children are cancelled, but exception <span class="keyword">is</span> not handled until all children termination.</span><br><span class="line">The first child finished its non cancellable block.</span><br><span class="line">Caught java.lang.ArithmeticException</span><br></pre></td></tr></table></figure>

<h4 id="异常聚合"><a href="#异常聚合" class="headerlink" title="异常聚合"></a>异常聚合</h4><p>当协程的多个子协程因为异常而失败时，一般情况下取第一个异常进行处理。在第一个异常之后发生的所有其它异常，都将被绑定到第一个异常之上。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test exception aggreation`<span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> handler = CoroutineExceptionHandler &#123; _, excption -&gt;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$excption</span> <span class="subst">$&#123;excption.suppressed.contentToString()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch(handler) &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                delay(<span class="built_in">Long</span>.MAX_VALUE)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> ArithmeticException()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                delay(<span class="built_in">Long</span>.MAX_VALUE)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> IndexOutOfBoundsException()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            <span class="keyword">throw</span> IOException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Caught java.io.IOException [java.lang.IndexOutOfBoundsException, java.lang.ArithmeticException]</span><br></pre></td></tr></table></figure>

<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><h4 id="异步返回多个值的方案"><a href="#异步返回多个值的方案" class="headerlink" title="异步返回多个值的方案"></a>异步返回多个值的方案</h4><p>集合、序列、挂起函数、Flow。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回了多个值，但不是异步</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleList</span><span class="params">()</span></span> = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回了多个值，但不是异步（一次返回一个值）</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleSequence</span><span class="params">()</span></span> = sequence &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>) <span class="comment">// 阻塞</span></span><br><span class="line"><span class="comment">//            delay(1000) // 不能用</span></span><br><span class="line">        yield(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回了多个值，是异步（一次性返回了多个值）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleList2</span><span class="params">()</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回了多个值，是异步（一次返回一个值）</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>) <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        emit(i) <span class="comment">// 发射，返回一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test multiple values`<span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//        simpleList().forEach &#123; println(it) &#125;</span></span><br><span class="line">    simpleSequence().forEach &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test multiple values2`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    simpleList2().forEach &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test multiple values3`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 启动另外一个协程，证明 simpleFlow 没有阻塞主线程</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m not blocked <span class="variable">$i</span>.&quot;</span>)</span><br><span class="line">            delay(<span class="number">1500</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    simpleFlow().collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Flow-与其它方式的区别"><a href="#Flow-与其它方式的区别" class="headerlink" title="Flow 与其它方式的区别"></a>Flow 与其它方式的区别</h4><ul>
<li>名为 flow 的 Flow 类型构建器函数。</li>
<li>flow{…} 构建块中的代码可以挂起。</li>
<li>函数 simpleFlow 不再标有 suspend 修饰符。</li>
<li>流使用 emit 函数发射值。</li>
<li>流使用 collect 函数收集值。</li>
</ul>
<p><img data-src="https://gitee.com/zch0304/images/raw/master/note/1663391441985.png"> </p>
<h4 id="冷流"><a href="#冷流" class="headerlink" title="冷流"></a>冷流</h4><p>Flow 是一种类似于序列的冷流，flow 构建器中的代码直到流被收集的时候才运行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow2</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">    println(<span class="string">&quot;Flow started.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow <span class="keyword">is</span> cold`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> flow = simpleFlow2()</span><br><span class="line">    println(<span class="string">&quot;Calling collect...&quot;</span>)</span><br><span class="line">    flow.collect &#123; println(it) &#125;</span><br><span class="line">    println(<span class="string">&quot;Calling collect again...&quot;</span>)</span><br><span class="line">    flow.collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Calling collect...</span><br><span class="line">Flow started.</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Calling collect again...</span><br><span class="line">Flow started.</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="流的连续性"><a href="#流的连续性" class="headerlink" title="流的连续性"></a>流的连续性</h4><ul>
<li>流的每次单独收集都是按顺序执行的，除非使用特殊操作符。</li>
<li>从上游到下游每个过渡操作符都会处理每个发射出的值，然后再交给末端操作符。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow continuation`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.5</span>).asFlow().filter &#123;</span><br><span class="line">        it % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        <span class="string">&quot;string <span class="variable">$it</span>&quot;</span></span><br><span class="line">    &#125;.collect &#123;</span><br><span class="line">        println(<span class="string">&quot;Collect <span class="variable">$it</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Collect string <span class="number">2.</span></span><br><span class="line">Collect string <span class="number">4.</span></span><br></pre></td></tr></table></figure>

<h4 id="流构建器"><a href="#流构建器" class="headerlink" title="流构建器"></a>流构建器</h4><ul>
<li>flowOf 构建器定义了一个发射固定值集的流。</li>
<li>使用 .asFlow() 扩展函数，可以将各种集合与序列转换为流。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow builder`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flowOf(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>)</span><br><span class="line">        .onEach &#123; delay(<span class="number">1000</span>) &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow().collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流上下文"><a href="#流上下文" class="headerlink" title="流上下文"></a>流上下文</h4><ul>
<li>流的收集总是在调用协程的上下文中发生，流的该属性称为<strong>上下文保存</strong>。</li>
<li>flow{…} 构建器中的代码必须遵循上下文保存属性，并且不允许从其它上下文中发射（emit）。</li>
<li>flowOn 操作符，该函数用于更改流发射的上下文。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow3</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">    println(<span class="string">&quot;Flow started <span class="subst">$&#123;Thread.currentThread().name&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow on`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    simpleFlow3().collect &#123; println(<span class="string">&quot;Collected <span class="variable">$it</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Flow started DefaultDispatcher-worker-<span class="number">1</span> <span class="meta">@coroutine</span>#<span class="number">2.</span></span><br><span class="line">Collected <span class="number">1</span> Test worker <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">Collected <span class="number">2</span> Test worker <span class="meta">@coroutine</span>#<span class="number">1</span></span><br><span class="line">Collected <span class="number">3</span> Test worker <span class="meta">@coroutine</span>#<span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果去掉 .flowOn(Dispatchers.Default)，那么发射和收集都是在 Test worker 线程中。</p>
</blockquote>
<h4 id="在指定协程中收集流"><a href="#在指定协程中收集流" class="headerlink" title="在指定协程中收集流"></a>在指定协程中收集流</h4><p>使用 launchIn 替换 collect，我们可以在单独的协程中启动流的收集。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">events</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">100</span>) &#125;.flowOn(Dispatchers.Default)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow launchIn`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = events()</span><br><span class="line">        .onEach &#123; println(<span class="string">&quot;Event: <span class="variable">$it</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>) &#125;</span><br><span class="line"><span class="comment">//            .launchIn(CoroutineScope(Dispatchers.IO))</span></span><br><span class="line">        .launchIn(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//        delay(200)</span></span><br><span class="line"><span class="comment">//        job.cancelAndJoin()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Event: <span class="number">1</span> Test worker <span class="meta">@coroutine</span>#<span class="number">2</span></span><br><span class="line">Event: <span class="number">2</span> Test worker <span class="meta">@coroutine</span>#<span class="number">2</span></span><br><span class="line">Event: <span class="number">3</span> Test worker <span class="meta">@coroutine</span>#<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="流的取消"><a href="#流的取消" class="headerlink" title="流的取消"></a>流的取消</h4><p>流采用与协程同样的协作取消。像往常一样，流的收集可以是当流在一个可取消的挂起函数（例如 delay）中挂起的时候取消。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow4</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>.&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test cancel flow`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    withTimeoutOrNull(<span class="number">2500</span>) &#123;</span><br><span class="line">        simpleFlow4().collect &#123; println(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Emitting <span class="number">1.</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Emitting <span class="number">2.</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<h4 id="流的取消检测"><a href="#流的取消检测" class="headerlink" title="流的取消检测"></a>流的取消检测</h4><ul>
<li><p>为方便起见，流构建器对每个发射值执行附加的 ensureActive 检测以进行取消，这意味着从 flow{…} 发出的繁忙循环是可以取消的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow5</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>.&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test cancel flow check`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    simpleFlow5().collect &#123;</span><br><span class="line">        println(it)</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Emitting <span class="number">1.</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Emitting <span class="number">2.</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Emitting <span class="number">3.</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">BlockingCoroutine was cancelled</span><br><span class="line">kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=<span class="string">&quot;coroutine#1&quot;</span>:BlockingCoroutine&#123;Cancelled&#125;@5da3da3d</span><br></pre></td></tr></table></figure>
</li>
<li><p>出于性能原因，大多数其它流操作不会自动执行其它取消检测，在协程处于繁忙循环的情况下，必须明确检测是否取消，通过 <strong>cancellable</strong> 操作符来执行此操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test cancel flow check`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.5</span>).asFlow().cancellable().collect &#123;</span><br><span class="line">        println(it)</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">BlockingCoroutine was cancelled</span><br><span class="line">kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=<span class="string">&quot;coroutine#1&quot;</span>:BlockingCoroutine&#123;Cancelled&#125;@63bbd396</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h4><p><strong>1、使用缓冲与 flowOn 处理背压</strong></p>
<ul>
<li><p>buffer()：并发运行流中发射元素的代码。</p>
</li>
<li><p>当必须更改 CoroutineDispatcher 时，flowOn 操作符使用了相同的缓冲机制，但是 buffer 函数显示地请求缓冲而<strong>不改变执行上下文</strong>。</p>
</li>
</ul>
<p><strong>2、合并与处理最新值</strong></p>
<ul>
<li>conflate()：合并发射项，不对每个值进行处理。</li>
<li>collectLastest()：取消并重新发射最后一个值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow6</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow back pressure`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simpleFlow6()</span><br><span class="line"><span class="comment">//                .buffer(50) // 并行发射 3 个元素，需要 100 ms</span></span><br><span class="line"><span class="comment">//                .flowOn(Dispatchers.Default) // 让发射在后台线程，也是并行发射，需要 100 ms</span></span><br><span class="line"><span class="comment">//                .conflate()</span></span><br><span class="line"><span class="comment">//                .collect &#123;</span></span><br><span class="line">            .collectLatest &#123;</span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 处理这个元素消耗 300 ms</span></span><br><span class="line">                println(<span class="string">&quot;Collected <span class="variable">$it</span> <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Collected in <span class="variable">$time</span> ms.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不处理背压情况下，上面程序大概需要消耗 （100 + 300）* 3 &#x3D; 1200 ms。</p>
<ul>
<li>使用 buffer()，大概需要 100 + 3 * 300 &#x3D; 1000 ms，因为该方式发射元素是异步的。</li>
<li>使用 flowOn 操作符，也是大概需要 100 + 3 * 300 &#x3D; 1000 ms，该方式发射元素也是异步，但是发射元素切换到了后台线程。</li>
<li>使用 conflate，合并发射项，不对每个值进行处理，大概需要 100 + 2 * 300 &#x3D; 700 ms。该方式发射元素是异步的，收集过程忽略了中间的元素，只处理了前后两个元素。</li>
<li>使用 collectLastest，上面程序大概需要消耗 700 ms。该方式发射元素也是异步，它会取消并重新发射最后一个值。</li>
</ul>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><h5 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h5><ul>
<li>可以使用操作符转换流，就像使用集合与序列一样。</li>
<li>转换操作符应用于上游流，并返回下游流。</li>
<li>这些操作符也是冷操作符，就像流一样。这类操作符本身不是挂起函数。</li>
<li>它运行的速度很快，返回新的转换流的定义。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performRequest</span><span class="params">(request: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;response <span class="variable">$request</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test transform flow <span class="keyword">operator</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line"><span class="comment">//            .map &#123; performRequest(it) &#125;</span></span><br><span class="line">        .transform &#123;</span><br><span class="line">            emit(<span class="string">&quot;Making request <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">            emit(performRequest(it))</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map 转换一次。transform 可以转换发射多次。</p>
<h5 id="限长操作符"><a href="#限长操作符" class="headerlink" title="限长操作符"></a>限长操作符</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">numbers</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        emit(<span class="number">2</span>)</span><br><span class="line">        println(<span class="string">&quot;This line will not execute.&quot;</span>)</span><br><span class="line">        emit(<span class="number">3</span>)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Finally in numbers.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test limit length <span class="keyword">operator</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    numbers().take(<span class="number">2</span>).collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Finally <span class="keyword">in</span> numbers.</span><br></pre></td></tr></table></figure>

<h5 id="末端流操作符"><a href="#末端流操作符" class="headerlink" title="末端流操作符"></a>末端流操作符</h5><p>末端流操作符是在流上用于启动流收集的挂起函数。collect 是最基础的末端操作符，但是还有另外一些更方便的使用的末端操作符：</p>
<ul>
<li>转化为各种集合，例如 toList 与 toSet。</li>
<li>获取第一个（first）值与确保流发射单个（Single）值的操作符。</li>
<li>使用 reduce 与 fold 将流规约到单个值。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test terminal <span class="keyword">operator</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> sum = (<span class="number">1.</span><span class="number">.5</span>).asFlow()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .reduce &#123; a, b -&gt; a + b &#125;</span><br><span class="line">    println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

<h5 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h5><p>就像 Kotlin 标准库中的 Sequence.zip 扩展函数一样，流拥有一个 zip 操作符用于组合两个流中的相关值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test zip <span class="keyword">operator</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> numbs = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">    <span class="keyword">val</span> strs = flowOf(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>)</span><br><span class="line">    numbs.zip(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125;.collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span> -&gt; One</span><br><span class="line"><span class="number">2</span> -&gt; Two</span><br><span class="line"><span class="number">3</span> -&gt; Three</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test zip2 <span class="keyword">operator</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> numbs = (<span class="number">1.</span><span class="number">.3</span>).asFlow().onEach &#123; delay(<span class="number">300</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> strs = flowOf(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>).onEach &#123; delay(<span class="number">400</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    numbs.zip(strs) &#123; a, b -&gt; <span class="string">&quot;<span class="variable">$a</span> -&gt; <span class="variable">$b</span>&quot;</span> &#125;.collect &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$it</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span> -&gt; One at <span class="number">442</span> ms from start.</span><br><span class="line"><span class="number">2</span> -&gt; Two at <span class="number">839</span> ms from start.</span><br><span class="line"><span class="number">3</span> -&gt; Three at <span class="number">1246</span> ms from start.</span><br></pre></td></tr></table></figure>

<h5 id="展平操作符"><a href="#展平操作符" class="headerlink" title="展平操作符"></a>展平操作符</h5><p>流表示异步接收的值序列，所以很容易遇到这样的情况：每个值都会触发对另一个值序列的请求，然而，由于流具有异步的性质，因此需要不同的展平模式，存在一系列的流展平操作符：</p>
<ul>
<li>flatMapConcat 连接模式。</li>
<li>flatMapMerge 合并模式。</li>
<li>flatMapLastest 最新展平模式。</li>
</ul>
<p><img data-src="https://gitee.com/zch0304/images/raw/master/note/1663680667795.jpg"> </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestFlow</span><span class="params">(i: <span class="type">Int</span>)</span></span> = flow&lt;String&gt; &#123;</span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: First.&quot;</span>)</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    emit(<span class="string">&quot;<span class="variable">$i</span>: Second.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flatMapConcat <span class="keyword">operator</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .onEach &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;.flatMapConcat &#123;</span><br><span class="line">            requestFlow(it)</span><br><span class="line">        &#125;.collect &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$it</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span>: First. at <span class="number">138</span> ms from start.</span><br><span class="line"><span class="number">1</span>: Second. at <span class="number">665</span> ms from start.</span><br><span class="line"><span class="number">2</span>: First. at <span class="number">774</span> ms from start.</span><br><span class="line"><span class="number">2</span>: Second. at <span class="number">1289</span> ms from start.</span><br><span class="line"><span class="number">3</span>: First. at <span class="number">1398</span> ms from start.</span><br><span class="line"><span class="number">3</span>: Second. at <span class="number">1911</span> ms from start.</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flatMapMerge <span class="keyword">operator</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .onEach &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;.flatMapMerge &#123;</span><br><span class="line">            requestFlow(it)</span><br><span class="line">        &#125;.collect &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$it</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span>: First. at <span class="number">192</span> ms from start.</span><br><span class="line"><span class="number">2</span>: First. at <span class="number">293</span> ms from start.</span><br><span class="line"><span class="number">3</span>: First. at <span class="number">404</span> ms from start.</span><br><span class="line"><span class="number">1</span>: Second. at <span class="number">698</span> ms from start.</span><br><span class="line"><span class="number">2</span>: Second. at <span class="number">806</span> ms from start.</span><br><span class="line"><span class="number">3</span>: Second. at <span class="number">919</span> ms from start.</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flatMapLatest <span class="keyword">operator</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line">        .onEach &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;.flatMapLatest &#123;</span><br><span class="line">            requestFlow(it)</span><br><span class="line">        &#125;.collect &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="variable">$it</span> at <span class="subst">$&#123;System.currentTimeMillis() - startTime&#125;</span> ms from start.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span>: First. at <span class="number">178</span> ms from start.</span><br><span class="line"><span class="number">2</span>: First. at <span class="number">326</span> ms from start.</span><br><span class="line"><span class="number">3</span>: First. at <span class="number">441</span> ms from start.</span><br><span class="line"><span class="number">3</span>: Second. at <span class="number">943</span> ms from start.</span><br></pre></td></tr></table></figure>

<h4 id="流的异常处理"><a href="#流的异常处理" class="headerlink" title="流的异常处理"></a>流的异常处理</h4><p>当运算符中的发射器或代码抛出异常时，有几种处理异常的方法：</p>
<ul>
<li>try&#x2F;catch 块。</li>
<li>catch 函数。</li>
</ul>
<p><strong>1、捕获下游异常</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">exceptionFlow</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Emitting <span class="variable">$i</span>.&quot;</span>)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow exception`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        exceptionFlow().collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">            check(it &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="string">&quot;Collect <span class="variable">$it</span>.&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Emitting <span class="number">1.</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Emitting <span class="number">2.</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Caught java.lang.IllegalStateException: Collect <span class="number">2.</span></span><br></pre></td></tr></table></figure>

<p><strong>2、捕获上游异常</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow exception2`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0.&quot;</span>)</span><br><span class="line">    &#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;.flowOn(Dispatchers.IO)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Caught java.lang.ArithmeticException: Div <span class="number">0.</span></span><br></pre></td></tr></table></figure>

<p><strong>3、恢复异常</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow exception3`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        <span class="keyword">throw</span> ArithmeticException(<span class="string">&quot;Div 0.&quot;</span>)</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">    &#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        emit(<span class="number">10</span>)</span><br><span class="line">    &#125;.flowOn(Dispatchers.IO)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Caught java.lang.ArithmeticException: Div <span class="number">0.</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="流的完成"><a href="#流的完成" class="headerlink" title="流的完成"></a>流的完成</h4><p>当流收集完成时（普通情况或异常情况），它可能需要执行一个动作。</p>
<ul>
<li>命令式 finally 块。</li>
<li>onCompletion 声明式处理。</li>
</ul>
<p>1、finally 形式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow complete <span class="keyword">in</span> <span class="keyword">finally</span>`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow</span><span class="params">()</span></span> = (<span class="number">1.</span><span class="number">.3</span>).asFlow()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        simpleFlow().collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Done.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<p>2、onCompletion 函数可以拿到上游异常信息，但捕获异常还是需要 catch 函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow complete <span class="keyword">in</span> onCompletion`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">    &#125;</span><br><span class="line">    simpleFlow()</span><br><span class="line">        .onCompletion &#123; exception -&gt;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;Flow completed exceptionally.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="keyword">catch</span> &#123; exception -&gt;</span><br><span class="line">            println(<span class="string">&quot;Caught <span class="variable">$exception</span>.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Flow completed exceptionally.</span><br><span class="line">Caught java.lang.RuntimeException.</span><br></pre></td></tr></table></figure>

<p>3、onCompletion 函数也能拿到下游异常信息，但捕获异常需要用 try&#x2F;catch 形式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test flow complete <span class="keyword">in</span> onCompletion2`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">simpleFlow</span><span class="params">()</span></span> = flow &#123;</span><br><span class="line">        emit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        simpleFlow()</span><br><span class="line">            .onCompletion &#123; exception -&gt;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                    println(<span class="string">&quot;Flow completed exceptionally.&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.collect &#123;</span><br><span class="line">                println(it)</span><br><span class="line">                check(it &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="string">&quot;Collect <span class="variable">$it</span>.&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;Caught <span class="variable">$e</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Flow completed exceptionally.</span><br><span class="line">Caught java.lang.RuntimeException.</span><br></pre></td></tr></table></figure>

<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h4 id="什么是-Channel"><a href="#什么是-Channel" class="headerlink" title="什么是 Channel"></a>什么是 Channel</h4><p>Channel 实际上是一个<strong>并发安全的队列</strong>，它可以用来连接协程，实现不同协程的通信。</p>
<p><img data-src="https://gitee.com/zch0304/images/raw/master/note/1666439476014.jpg"> </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test know Channel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            println(<span class="string">&quot;send <span class="variable">$i</span>.&quot;</span>)</span><br><span class="line">            channel.send(i++)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// delay(3000)</span></span><br><span class="line">            <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">            println(<span class="string">&quot;receive <span class="variable">$element</span>.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    joinAll(producer, consumer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">send <span class="number">1.</span></span><br><span class="line">receive <span class="number">1.</span></span><br><span class="line">send <span class="number">2.</span></span><br><span class="line">receive <span class="number">2.</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="Channel-的容量"><a href="#Channel-的容量" class="headerlink" title="Channel 的容量"></a>Channel 的容量</h4><p>Channel 实际上就是一个队列，队列中一定存在缓冲区，那么一旦这个缓冲区满了，并且一直没有人调用 receive 并取走函数，send 就需要挂起。故意让接收端的节奏放慢，发现 send 总是会挂起，直到 receive 之后才会继续往下执行。</p>
<p>比如上面的代码让消费者延迟 3s，那么生产者 send 一个元素后，需要等消费者在 3s 之后 receive 到元素才能 send 下一个元素。因为 Channel 默认的容量是 0。</p>
<h4 id="迭代-Channel"><a href="#迭代-Channel" class="headerlink" title="迭代 Channel"></a>迭代 Channel</h4><p>Channel 本身确实像序列，所以我们在读取的时候可以直接获取一个 Channel 的 iterator。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test iterator Channel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(Channel.UNLIMITED)</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> element = i * i</span><br><span class="line">            println(<span class="string">&quot;send <span class="variable">$element</span>.&quot;</span>)</span><br><span class="line">            channel.send(element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line"><span class="comment">//            val it = channel.iterator()</span></span><br><span class="line"><span class="comment">//            while (it.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">//                val element = it.next()</span></span><br><span class="line"><span class="comment">//                println(&quot;receive $element.&quot;)</span></span><br><span class="line"><span class="comment">//                delay(2000)</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;receive <span class="variable">$element</span>.&quot;</span>)</span><br><span class="line">            delay(<span class="number">2000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    joinAll(producer, consumer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">send <span class="number">1.</span></span><br><span class="line">send <span class="number">4.</span></span><br><span class="line">send <span class="number">9.</span></span><br><span class="line">send <span class="number">16.</span></span><br><span class="line">send <span class="number">25.</span></span><br><span class="line">receive <span class="number">1.</span></span><br><span class="line">receive <span class="number">4.</span></span><br><span class="line">receive <span class="number">9.</span></span><br><span class="line">receive <span class="number">16.</span></span><br><span class="line">receive <span class="number">25.</span></span><br></pre></td></tr></table></figure>

<h4 id="produce-与-actor"><a href="#produce-与-actor" class="headerlink" title="produce 与 actor"></a>produce 与 actor</h4><ul>
<li>构造生产者与消费者的<strong>便捷方法</strong>。</li>
<li>我们可以通过 produce 方法启动一个生产者协程，并返回一个 ReceiveChannel，其它协程就可以用这个 Channel 来接收数据了。反过来，我们可以用 actor 启动一个消费者协程。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test fast producer Channel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> receiveChannel: ReceiveChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.produce &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            send(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> receiveChannel) &#123;</span><br><span class="line">            println(<span class="string">&quot;receive <span class="variable">$element</span>.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">receive <span class="number">0.</span></span><br><span class="line">receive <span class="number">1.</span></span><br><span class="line">receive <span class="number">2.</span></span><br><span class="line">receive <span class="number">3.</span></span><br><span class="line">receive <span class="number">4.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test fast consumer Channel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> sendChannel: SendChannel&lt;<span class="built_in">Int</span>&gt; = GlobalScope.actor&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> element = receive()</span><br><span class="line">            println(<span class="string">&quot;receive <span class="variable">$element</span>.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.3</span>) &#123;</span><br><span class="line">            sendChannel.send(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    producer.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">receive <span class="number">0.</span></span><br><span class="line">receive <span class="number">1.</span></span><br><span class="line">receive <span class="number">2.</span></span><br><span class="line">receive <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<h4 id="Channel-的关闭"><a href="#Channel-的关闭" class="headerlink" title="Channel 的关闭"></a>Channel 的关闭</h4><ul>
<li>produce 和 actor 返回的 Channel 都会随着对应的协程执行完毕而关闭，也正是这样，Channel 才被称为<strong>热数据流</strong>。</li>
<li>对于一个 Channel，如果我们调用了它的 close 方法，它会立即停止接收新元素，也就是说这时它的 <strong>isClosedForSend</strong> 会立即返回 true。而由于 Channel 缓冲区的存在，这时候可能还有一些元素没有被处理完，因此要等所有的元素都被读取之后 isCloseForReceive 才会返回 true。</li>
<li>Channel 的生命周期最好由主导方来维护，建议<strong>由主导的一方实现关闭</strong>。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test close Channel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        List(<span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;send <span class="variable">$it</span>.&quot;</span>)</span><br><span class="line">            channel.send(it)</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close()</span><br><span class="line">        println(<span class="string">&quot;Close Channel. | - ClosedForSend: <span class="subst">$&#123;channel.isClosedForSend&#125;</span>. | - ClosedForReceive: <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(<span class="string">&quot;receive <span class="variable">$element</span>.&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;After Consuming. | - ClosedForSend: <span class="subst">$&#123;channel.isClosedForSend&#125;</span>. | - ClosedForReceive: <span class="subst">$&#123;channel.isClosedForReceive&#125;</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    joinAll(producer, consumer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">send <span class="number">0.</span></span><br><span class="line">send <span class="number">1.</span></span><br><span class="line">send <span class="number">2.</span></span><br><span class="line">receive <span class="number">0.</span></span><br><span class="line">Close Channel. | - ClosedForSend: <span class="literal">true</span>. | - ClosedForReceive: <span class="literal">false</span>.</span><br><span class="line">receive <span class="number">1.</span></span><br><span class="line">receive <span class="number">2.</span></span><br><span class="line">After Consuming. | - ClosedForSend: <span class="literal">true</span>. | - ClosedForReceive: <span class="literal">true</span>.</span><br></pre></td></tr></table></figure>

<h4 id="BroadcastChannel"><a href="#BroadcastChannel" class="headerlink" title="BroadcastChannel"></a>BroadcastChannel</h4><p>前面提到，发送端和接收端在 Channel 中存在一对多的情形，从数据处理本身来讲，虽然有多个接收端，但是同一个元素只会被一个接收端读到。广播则不然，<strong>多个接收端不存在互斥行为</strong>。</p>
<p><img data-src="https://gitee.com/zch0304/images/raw/master/note/1666502596729.jpg"> </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test broadcastChannel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"><span class="comment">//        val broadcastChannel = BroadcastChannel&lt;Int&gt;(Channel.BUFFERED)</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> broadcastChannel = channel.broadcast(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        List(<span class="number">3</span>) &#123;</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">            broadcastChannel.send(it)</span><br><span class="line">        &#125;</span><br><span class="line">        broadcastChannel.close()</span><br><span class="line">    &#125;</span><br><span class="line">    List(<span class="number">3</span>) &#123; index -&gt;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> receiveChannel = broadcastChannel.openSubscription()</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> receiveChannel) &#123;</span><br><span class="line">                println(<span class="string">&quot;[#<span class="variable">$index</span>] receive: <span class="variable">$i</span>.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.joinAll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">[#<span class="number">2</span>] receive: <span class="number">0.</span></span><br><span class="line">[#<span class="number">0</span>] receive: <span class="number">0.</span></span><br><span class="line">[#<span class="number">1</span>] receive: <span class="number">0.</span></span><br><span class="line">[#<span class="number">1</span>] receive: <span class="number">1.</span></span><br><span class="line">[#<span class="number">2</span>] receive: <span class="number">1.</span></span><br><span class="line">[#<span class="number">0</span>] receive: <span class="number">1.</span></span><br><span class="line">[#<span class="number">1</span>] receive: <span class="number">2.</span></span><br><span class="line">[#<span class="number">2</span>] receive: <span class="number">2.</span></span><br><span class="line">[#<span class="number">0</span>] receive: <span class="number">2.</span></span><br></pre></td></tr></table></figure>

<h3 id="select-多路复用"><a href="#select-多路复用" class="headerlink" title="select - 多路复用"></a>select - 多路复用</h3><h4 id="什么是多路复用"><a href="#什么是多路复用" class="headerlink" title="什么是多路复用"></a>什么是多路复用</h4><p>数据通信系统或计算机网络系统中，传输媒体的带宽或容量往往会大于传输单一信号的需求，为了有效地利用通信线路，希望<strong>一个信道同时传输多路信号</strong>，这就是所谓的多路复用技术（Multiplexing）。</p>
<h4 id="复用多个-await"><a href="#复用多个-await" class="headerlink" title="复用多个 await"></a>复用多个 await</h4><p>两个 API 分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示。</p>
<p><img data-src="https://gitee.com/zch0304/images/raw/master/note/1666531343879.png">  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Response</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> value: T, <span class="keyword">val</span> isLocal: <span class="built_in">Boolean</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromLocal</span><span class="params">(name: <span class="type">String</span>)</span></span> = async(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    User(name, <span class="string">&quot;Local&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">getUserFromServer</span><span class="params">(name: <span class="type">String</span>)</span></span> = async(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">    User(name, <span class="string">&quot;Server&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test select await`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> localRequest = getUserFromLocal(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> serverRequest = getUserFromServer(<span class="string">&quot;BBB&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> userResponse = select&lt;Response&lt;User&gt;&gt; &#123;</span><br><span class="line">            localRequest.onAwait &#123; Response(it, <span class="literal">true</span>) &#125;</span><br><span class="line">            serverRequest.onAwait &#123; Response(it, <span class="literal">false</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userResponse.value.let &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.join()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">User(name=AAA, address=Local)</span><br></pre></td></tr></table></figure>

<h4 id="复用多个-Channel"><a href="#复用多个-Channel" class="headerlink" title="复用多个 Channel"></a>复用多个 Channel</h4><p>跟 await 类似，会接收到最快的那个 Channel 消息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test select Channel`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channels = listOf(Channel&lt;<span class="built_in">Int</span>&gt;(), Channel&lt;<span class="built_in">Int</span>&gt;())</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        channels[<span class="number">0</span>].send(<span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">50</span>)</span><br><span class="line">        channels[<span class="number">1</span>].send(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> result = select&lt;<span class="built_in">Int</span>?&gt; &#123;</span><br><span class="line">        channels.forEach &#123; channel -&gt;</span><br><span class="line">            channel.onReceive &#123; it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h4 id="SelectClause"><a href="#SelectClause" class="headerlink" title="SelectClause"></a>SelectClause</h4><p>我们怎么知道哪些事件可以被 <strong>select</strong> 呢？其实所有能够被 select 的事件都是 <strong>SelectClauseN</strong> 类型，包括：</p>
<ul>
<li><p><strong>SelectClause0</strong>：对应事件没有返回值，例如 join 没有返回值，对应的 onJoin 就是这个类型，使用时 onJoin 的参数是一个无参函数。</p>
</li>
<li><p><strong>SelectClause1</strong>：对应事件有返回值，前面的 onAwait 和 onReceive 都是此类情况。</p>
</li>
<li><p><strong>SelectClause2</strong>：对应事件有返回值，此外还需要额外的一个参数，例如 Channel.onSend 有两个参数，第一个就是一个 Channel 数据类型的值，表示即将发送的值，第二个是发送成功时的回调。</p>
</li>
</ul>
<p>如果我们想要确认挂起函数是否支持 select，只需要查看其是否存在对应的 SelectClauseN 即可。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test SelectClause0`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;job 1&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> job2 = GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;job 2&quot;</span>)</span><br><span class="line">        delay(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        job1.onJoin &#123;</span><br><span class="line">            println(<span class="string">&quot;job 1 onJoin&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        job2.onJoin &#123;</span><br><span class="line">            println(<span class="string">&quot;job 2 onJoin&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">job <span class="number">1</span></span><br><span class="line">job <span class="number">2</span></span><br><span class="line">job <span class="number">2</span> onJoin</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test SelectClause2`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> channels = listOf(Channel&lt;<span class="built_in">Int</span>&gt;(), Channel&lt;<span class="built_in">Int</span>&gt;())</span><br><span class="line">    println(channels)</span><br><span class="line">    launch(Dispatchers.IO) &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">10</span>)</span><br><span class="line">                channels[<span class="number">1</span>].onSend(<span class="number">200</span>) &#123; sentChannel -&gt;</span><br><span class="line">                    println(<span class="string">&quot;sent on <span class="variable">$sentChannel</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay(<span class="number">100</span>)</span><br><span class="line">                channels[<span class="number">0</span>].onSend(<span class="number">100</span>) &#123; sentChannel -&gt;</span><br><span class="line">                    println(<span class="string">&quot;sent on <span class="variable">$sentChannel</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(channels[<span class="number">0</span>].receive())</span><br><span class="line">    &#125;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(channels[<span class="number">1</span>].receive())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">[<span class="symbol">RendezvousChannel@</span>24c4ddae&#123;EmptyQueue&#125;, <span class="symbol">RendezvousChannel@</span><span class="number">766653e6</span>&#123;EmptyQueue&#125;]</span><br><span class="line"><span class="number">200</span></span><br><span class="line">sent on <span class="symbol">RendezvousChannel@</span><span class="number">766653e6</span>&#123;EmptyQueue&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Flow-实现多路复用"><a href="#使用-Flow-实现多路复用" class="headerlink" title="使用 Flow 实现多路复用"></a>使用 Flow 实现多路复用</h4><p>多数情况下，我们可以通过构造合适的 Flow 来实现多路复用的效果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test select flow`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">// 函数 -&gt; 协程 -&gt; Flow -&gt; Flow 合并</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;guest&quot;</span></span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        listOf(::getUserFromLocal, ::getUserFromServer)</span><br><span class="line">            .map &#123; function -&gt;</span><br><span class="line">                function.call(name)</span><br><span class="line">            &#125;.map &#123; deferred -&gt;</span><br><span class="line">                flow &#123;</span><br><span class="line">                    emit(deferred.await())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.merge()</span><br><span class="line">            .collect &#123; user -&gt;</span><br><span class="line">                println(user)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">User(name=guest, address=Local)</span><br><span class="line">User(name=guest, address=Server)</span><br></pre></td></tr></table></figure>

<h3 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h3><p>由于协程是基于线程的，既然线程有并发问题，那么协程也一定有。</p>
<h4 id="不安全的并发访问"><a href="#不安全的并发访问" class="headerlink" title="不安全的并发访问"></a>不安全的并发访问</h4><p>我们使用线程在解决并发问题的时候总是会遇到线程安全问题，而 Java 平台上的 Kotlin 协程实现免不了存在并发调度的情况，因此线程安全同样值得留意。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test not safe concurrent`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    List(<span class="number">10000</span>) &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.joinAll()</span><br><span class="line">    println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果（每次打印可能不一样）</span></span><br><span class="line"><span class="number">9997</span></span><br></pre></td></tr></table></figure>

<p>Java API 中安全的并发访问：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test safe concurrent`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> count = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">    List(<span class="number">10000</span>) &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            count.incrementAndGet()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.joinAll()</span><br><span class="line">    println(count.<span class="keyword">get</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果（每次打印都一样）</span></span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<h4 id="协程的并发工具"><a href="#协程的并发工具" class="headerlink" title="协程的并发工具"></a>协程的并发工具</h4><p>除了我们在线程中常用的解决并发问题的手段之外，协程框架也提供了一些并发安全的工具，包括：</p>
<ul>
<li><strong>Channel</strong>：并发安全的消息通道，我们已经非常熟悉。</li>
<li><strong>Mutex</strong>：轻量级锁，它的 lock 和 unlock 从语义上与线程锁比较类似，之所以轻量是因为它在获取不到锁时不会阻塞线程，而是挂起等待锁的释放。</li>
<li><strong>Semaphore</strong>：轻量级信号量，信号量可以有多个，协程在获取到信号量后即可执行并发操作。当 Semaphore 的参数为 1 时，效果等价于 Mutex。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test safe concurrent tools`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> mutex = Mutex()</span><br><span class="line">    List(<span class="number">10000</span>) &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            mutex.withLock &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.joinAll()</span><br><span class="line">    println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果（每次打印都一样）</span></span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test safe concurrent tools2`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> semaphore = Semaphore(<span class="number">1</span>)</span><br><span class="line">    List(<span class="number">10000</span>) &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            semaphore.withPermit &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.joinAll()</span><br><span class="line">    println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免访问外部可变状态"><a href="#避免访问外部可变状态" class="headerlink" title="避免访问外部可变状态"></a>避免访问外部可变状态</h4><p>编写函数时要求它不得访问外部状态，只能基于参数做运算，通过返回值提供运算结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test avoid access outer variable`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> result = count + List(<span class="number">10000</span>) &#123;</span><br><span class="line">        GlobalScope.async &#123; <span class="number">1</span> &#125;</span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">        it.await()</span><br><span class="line">    &#125;.sum()</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果（每次打印都一样）</span></span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<h3 id="冷流还是热流"><a href="#冷流还是热流" class="headerlink" title="冷流还是热流"></a>冷流还是热流</h3><ul>
<li>Flow 是冷流，什么是冷流？简单来说，如果 Flow 有了订阅者 Collector 以后，发射出来的值才会实实在在的存在于内存之中，这跟懒加载的概念很像。</li>
<li>与之相对的是热流，StateFlow 和 SharedFlow 是热流，在垃圾回收之前，都是存在于内存之中，并且处于活跃状态的。</li>
</ul>
<h3 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h3><p>StateFlow 是一个状态容器式<strong>可观察数据流</strong>，可以向其收集器发出当前状态更新和新状态更新。还可通过其 value 属性读取当前状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StateFlow 与 LiveData 很像，但能使用 Flow 的操作符。</span></span><br><span class="line">    <span class="keyword">val</span> number = MutableStateFlow(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        number.value++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">decrement</span><span class="params">()</span></span> &#123;</span><br><span class="line">        number.value--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mNumberViewModel: NumberViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        </span><br><span class="line">        btnPlus.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 加法</span></span><br><span class="line">            mNumberViewModel.increment()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        btnMinus.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 减法</span></span><br><span class="line">            mNumberViewModel.decrement()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            <span class="comment">// 收集数据</span></span><br><span class="line">            mNumberViewModel.number.collect &#123;</span><br><span class="line">                tvNumber.text = it.toString()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SharedFlow"><a href="#SharedFlow" class="headerlink" title="SharedFlow"></a>SharedFlow</h3><p>SharedFlow 会向从其中收集值的所有使用方发出数据。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 SharedFlow 模拟 EventBus 收发数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> LocalEventBus &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> events = MutableSharedFlow&lt;Event&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">postEvent</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        events.emit(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Event</span>(<span class="keyword">val</span> timestamp: <span class="built_in">Long</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> job: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始刷新数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startRefresh</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 开启协程</span></span><br><span class="line">        job = viewModelScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                LocalEventBus.postEvent(Event(System.currentTimeMillis()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止刷新数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stopRefresh</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 关闭协程</span></span><br><span class="line">        job?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送数据界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedFlowFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mSharedViewModel: SharedViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        </span><br><span class="line">        btnStart.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 发送[开始刷新数据]指令</span></span><br><span class="line">            mSharedViewModel.startRefresh()</span><br><span class="line">        &#125;</span><br><span class="line">        btnStop.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 发送[停止刷新数据]指令</span></span><br><span class="line">            mSharedViewModel.stopRefresh()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收集数据界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextsFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        </span><br><span class="line"> 	    lifecycleScope.launch &#123;</span><br><span class="line">            <span class="comment">// 收集数据</span></span><br><span class="line">            LocalEventBus.events.collect &#123;</span><br><span class="line">                textView.text = <span class="string">&quot;<span class="subst">$&#123;tag&#125;</span>: <span class="subst">$&#123;it.timestamp&#125;</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flow-的应用"><a href="#Flow-的应用" class="headerlink" title="Flow 的应用"></a>Flow 的应用</h3><h4 id="Flow-与文件下载的应用"><a href="#Flow-与文件下载的应用" class="headerlink" title="Flow 与文件下载的应用"></a>Flow 与文件下载的应用</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">DownloadStatus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空状态</span></span><br><span class="line">    <span class="keyword">object</span> None : DownloadStatus()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载进度</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Progress</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : DownloadStatus()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> throwable: Throwable) : DownloadStatus()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Done</span>(<span class="keyword">val</span> file: File) : DownloadStatus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件管理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> DownloadManager &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url String 远程文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file File 下载到的本地文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Flow&lt;DownloadStatus&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">download</span><span class="params">(url: <span class="type">String</span>, file: <span class="type">File</span>)</span></span>: Flow&lt;DownloadStatus&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> flow &#123;</span><br><span class="line">            <span class="keyword">val</span> request = Request.Builder().url(url).<span class="keyword">get</span>().build()</span><br><span class="line">            <span class="keyword">val</span> response = OkHttpClient.Builder().build().newCall(request).execute()</span><br><span class="line">            <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">                response.body()!!.let &#123; body -&gt;</span><br><span class="line">                    <span class="keyword">val</span> total = body.contentLength()</span><br><span class="line">                    <span class="comment">// 文件读写</span></span><br><span class="line">                    file.outputStream().use &#123; outputStream -&gt;</span><br><span class="line">                        <span class="keyword">val</span> inputStream = body.byteStream()</span><br><span class="line">                        <span class="keyword">var</span> emittedProgress = <span class="number">0L</span></span><br><span class="line">                        inputStream.copyTo(outputStream) &#123; bytesCopied -&gt;</span><br><span class="line">                            <span class="keyword">val</span> progress = bytesCopied * <span class="number">100</span> / total</span><br><span class="line">                            <span class="keyword">if</span> (progress - emittedProgress &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                                delay(<span class="number">100</span>)</span><br><span class="line">                                emit(DownloadStatus.Progress(progress.toInt()))</span><br><span class="line">                                emittedProgress = progress</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                emit(DownloadStatus.Done(file))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> IOException(response.toString())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.<span class="keyword">catch</span> &#123;</span><br><span class="line">            file.delete()</span><br><span class="line">            emit(DownloadStatus.Error(it))</span><br><span class="line">        &#125;.flowOn(Dispatchers.IO)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展方法 读写文件并返回下载进度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@receiver</span> InputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out OutputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bufferSize Int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> progress Function1&lt;Long, Unit&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Long</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> InputStream.<span class="title">copyTo</span><span class="params">(<span class="keyword">out</span>: <span class="type">OutputStream</span>, bufferSize: <span class="type">Int</span> = DEFAULT_BUFFER_SIZE, progress: (<span class="type">Long</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bytesCopied: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> buffer = ByteArray(bufferSize)</span><br><span class="line">    <span class="keyword">var</span> bytes = read(buffer)</span><br><span class="line">    <span class="keyword">while</span> (bytes &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">out</span>.write(buffer, <span class="number">0</span>, bytes)</span><br><span class="line">        bytesCopied += bytes</span><br><span class="line">        bytes = read(buffer)</span><br><span class="line"></span><br><span class="line">        progress(bytesCopied)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytesCopied</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> URL = <span class="string">&quot;https://img1.baidu.com/it/u=413643897,2296924942&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">download</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// sdcard/Android/data/com.zch.flowpractice/files/pic.png</span></span><br><span class="line">        <span class="keyword">val</span> file = File(requireActivity().getExternalFilesDir(<span class="literal">null</span>)?.path, <span class="string">&quot;pic.jpg&quot;</span>)</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            DownloadManager.download(URL, file).collect &#123; status -&gt;</span><br><span class="line">                <span class="keyword">when</span> (status) &#123;</span><br><span class="line">                    <span class="keyword">is</span> DownloadStatus.Progress -&gt; &#123;</span><br><span class="line">                        progressBar.progress = status.value</span><br><span class="line">                        tvProgress.text = <span class="string">&quot;<span class="subst">$&#123;status.value&#125;</span>%&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">is</span> DownloadStatus.Error -&gt; &#123;</span><br><span class="line">                        ToastUtils.showLong(<span class="string">&quot;下载错误&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">is</span> DownloadStatus.Done -&gt; &#123;</span><br><span class="line">                        progressBar.progress = <span class="number">100</span></span><br><span class="line">                        tvProgress.text = <span class="string">&quot;100%&quot;</span></span><br><span class="line">                        ToastUtils.showShort(<span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                        ToastUtils.showShort(<span class="string">&quot;下载失败&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Flow-与-Room-的应用"><a href="#Flow-与-Room-的应用" class="headerlink" title="Flow 与 Room 的应用"></a>Flow 与 Room 的应用</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Room 实体类声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(</span><br><span class="line">    <span class="comment">// 主键</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">val</span> uid: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="comment">// 数据库里存入的字段名</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="string">&quot;first_name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> firstName: String,</span><br><span class="line">    <span class="comment">// 数据库里存入的字段名</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="string">&quot;last_name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> lastName: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dao 类声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 这里设置了一下冲突，如果两条记录相同则会替换</span></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(user: <span class="type">User</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不需要挂起（返回 Flow 或 LiveData 都不需要）</span></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;SELECT * FROM user&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: Flow&lt;List&lt;User&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库操作类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * entities      数据库里存入的表，可是多个</span></span><br><span class="line"><span class="comment"> * version       数据库的版本号</span></span><br><span class="line"><span class="comment"> * exportSchema  是否生成 json 文件，用于查看数据库的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Database(entities = [User::class], version = 1, exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDataBase</span> : <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dao 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">UserDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: AppDataBase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(context: <span class="type">Context</span>)</span></span>: AppDataBase &#123;</span><br><span class="line">            <span class="comment">// 对象锁</span></span><br><span class="line">            <span class="keyword">return</span> instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                Room.databaseBuilder(context, AppDataBase::<span class="keyword">class</span>.java, <span class="string">&quot;user_db&quot;</span>)</span><br><span class="line">                    .build().also &#123; instance = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User ViewModel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserViewModel</span>(app: Application) : AndroidViewModel(app) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            AppDataBase.getInstance(getApplication()).UserDao().insert(user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Flow&lt;List&lt;User&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: Flow&lt;List&lt;User&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> AppDataBase.getInstance(getApplication()).UserDao().getAll()</span><br><span class="line">            .<span class="keyword">catch</span> &#123; e -&gt;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;.flowOn(Dispatchers.IO)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFragment</span> : <span class="type">BaseBindingFragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding: FragmentUserBinding <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        FragmentUserBinding.inflate(layoutInflater)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mUserAdapter: UserAdapter <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        UserAdapter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mUserViewModel: UserViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBindingRoot</span><span class="params">()</span></span> = mBinding.root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mBinding.rvUser.adapter = mUserAdapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initEvent</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mBinding.btnAddUser.setOnClickListener &#123;</span><br><span class="line">            mBinding.run &#123;</span><br><span class="line">                <span class="comment">// 插入数据</span></span><br><span class="line">                mUserViewModel.insert(</span><br><span class="line">                    User(</span><br><span class="line">                        edtUid.text.toString().toInt(),</span><br><span class="line">                        edtFirstName.text.toString(),</span><br><span class="line">                        edtLastName.text.toString()</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            <span class="comment">// 获取所有数据</span></span><br><span class="line">            mUserViewModel.getAll().collect &#123;</span><br><span class="line">                mUserAdapter.submitList(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Flow-与-Retrofit-的应用"><a href="#Flow-与-Retrofit-的应用" class="headerlink" title="Flow 与 Retrofit 的应用"></a>Flow 与 Retrofit 的应用</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文章实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> id 文章 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> text 文章内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Article</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> text: String)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文章接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ArticleApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;article&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">searchArticle</span><span class="params">(<span class="meta">@Query(<span class="string">&quot;key&quot;</span>)</span> key: <span class="type">String</span>)</span></span>: List&lt;Article&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrofit 网络请求管理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> RetrofitClient &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> URL = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> instance: Retrofit <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        Retrofit.Builder()</span><br><span class="line">            .client(OkHttpClient.Builder().build())</span><br><span class="line">            .baseUrl(URL)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> articleApi: ArticleApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        instance.create(ArticleApi::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文章 ViewModel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> articles = MutableLiveData&lt;List&lt;Article&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">searchArticle</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        viewModelScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">            flow &#123;</span><br><span class="line">                <span class="keyword">val</span> list = RetrofitClient.articleApi.searchArticle(key)</span><br><span class="line">                emit(list)</span><br><span class="line">            &#125;.flowOn(Dispatchers.IO)</span><br><span class="line">                .<span class="keyword">catch</span> &#123; e -&gt; e.printStackTrace() &#125;</span><br><span class="line">                .collect &#123;</span><br><span class="line">                    articles.value = it</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文章界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleFragment</span> : <span class="type">BaseBindingFragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> articleViewModel <span class="keyword">by</span> viewModels&lt;ArticleViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding: FragmentArticleBinding <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        FragmentArticleBinding.inflate(layoutInflater)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBindingRoot</span><span class="params">()</span></span> = mBinding.root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initEvent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 请求数据</span></span><br><span class="line">        articleViewModel.searchArticle(<span class="string">&quot;三国演义&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 监听数据据返回</span></span><br><span class="line">        articleViewModel.articles.observe(viewLifecycleOwner) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>明年今日
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://zhich.github.io/2023/08/08/Kotlin-%E5%8D%8F%E7%A8%8B/" title="Kotlin 协程">https://zhich.github.io/2023/08/08/Kotlin-协程/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
              <a href="/tags/Kotlin/" rel="tag"><i class="fa fa-tag"></i> Kotlin</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/26/Kotlin-%E6%95%99%E7%A8%8B/" rel="prev" title="Kotlin 教程">
                  <i class="fa fa-angle-left"></i> Kotlin 教程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/18/%E9%B8%BF%E8%92%99%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/" rel="next" title="鸿蒙开发教程">
                  鸿蒙开发教程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Copyright © 明年今日。 All Rights Reserved.</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poaWNo" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://zhich.github.io/2023/08/08/Kotlin-%E5%8D%8F%E7%A8%8B/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
